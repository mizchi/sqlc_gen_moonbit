///|
fn async_run(f : async () -> Unit noraise) -> Unit = "%async.run"

// FFI declarations for native stdin/stdout handling
///|
extern "C" fn moonbit_read_stdin_size() -> Int64 = "moonbit_read_stdin_size"

///|
#borrow(dest)
extern "C" fn moonbit_copy_stdin_data(dest : Bytes) -> Unit = "moonbit_copy_stdin_data"

///|
#borrow(data)
extern "C" fn moonbit_write_all_stdout(data : Bytes, len : Int64) -> Int = "moonbit_write_all_stdout"

///|
#borrow(data)
extern "C" fn moonbit_write_stderr(data : Bytes, len : Int64) -> Int = "moonbit_write_stderr"

///|
fn main {
  // Read stdin
  let input = read_all_stdin()

  // Parse GenerateRequest from protobuf
  let reader = @protobuf.BytesReader::from_bytes(input)
  let mut request = @plugin.GenerateRequest::default()
  async_run(async fn() -> Unit noraise {
    request = @protobuf.AsyncRead::read(reader) catch {
      err => {
        write_stderr("Parse error: " + err.to_string() + "\n")
        @plugin.GenerateRequest::default()
      }
    }
  })
  
  // Generate code
  let files : Array[@plugin.File] = []
  let content = generate_code(request)
  files.push(@plugin.File::new("sqlc.mbt", string_to_utf8(content)))
  
  let response = @plugin.GenerateResponse::new(files)
  
  // Serialize response to protobuf and write to stdout
  let output = serialize_response(response)
  write_all_stdout(output)
}

///|
fn write_stderr(msg : String) -> Unit {
  let bytes = string_to_utf8(msg)
  let _ = moonbit_write_stderr(bytes, bytes.length().to_int64())
}

///|
fn generate_code(request : @plugin.GenerateRequest) -> String {
  let buf = StringBuilder::new()
  buf.write_string("// Generated by sqlc-gen-moonbit\n")
  buf.write_string("// sqlc version: ")
  buf.write_string(request.sqlc_version)
  buf.write_string("\n\n")

  // Generate helper functions
  buf.write_string("///|\nfn cstring(s : String) -> Bytes {\n")
  buf.write_string("  @encoding.encode(@encoding.UTF8, s)\n")
  buf.write_string("}\n\n")
  buf.write_string("///|\nfn bytes_to_string(b : Bytes) -> String {\n")
  buf.write_string("  let decoder = @encoding.decoder(@encoding.UTF8)\n")
  buf.write_string("  decoder.decode_lossy(b[0:b.length()])\n")
  buf.write_string("}\n\n")

  // Collect unique result structs from queries
  let generated_structs : Map[String, Bool] = {}

  // Generate result structs for queries that return data
  for query in request.queries {
    if query.cmd == ":one" || query.cmd == ":many" {
      let struct_name = to_pascal_case(query.name) + "Row"
      if not(generated_structs.contains(struct_name)) && query.columns.length() > 0 {
        generated_structs[struct_name] = true
        generate_result_struct(buf, struct_name, query.columns)
      }
    }
  }

  // Generate parameter structs for queries with parameters
  for query in request.queries {
    if query.params.length() > 0 {
      let struct_name = to_pascal_case(query.name) + "Params"
      generate_params_struct(buf, struct_name, query.params)
    }
  }

  // Generate SQL constants
  buf.write_string("// SQL queries\n")
  for query in request.queries {
    let const_name = to_snake_case(query.name) + "_sql"
    buf.write_string("pub let ")
    buf.write_string(const_name)
    buf.write_string(" : String = ")
    buf.write_string(escape_string(query.text))
    buf.write_string("\n\n")
  }

  // Generate query functions
  buf.write_string("// Query functions\n")
  for query in request.queries {
    generate_query_function(buf, query)
  }

  buf.to_string()
}

///|
fn generate_result_struct(
  buf : StringBuilder,
  name : String,
  columns : Array[@plugin.Column]
) -> Unit {
  buf.write_string("///|\npub struct ")
  buf.write_string(name)
  buf.write_string(" {\n")
  for col in columns {
    buf.write_string("  ")
    buf.write_string(to_snake_case(col.name))
    buf.write_string(" : ")
    buf.write_string(sql_type_to_moonbit(col))
    buf.write_string("\n")
  }
  buf.write_string("} derive(Show, Eq)\n\n")
}

///|
fn generate_params_struct(
  buf : StringBuilder,
  name : String,
  params : Array[@plugin.Parameter]
) -> Unit {
  buf.write_string("///|\npub struct ")
  buf.write_string(name)
  buf.write_string(" {\n")
  for param in params {
    let col = param.column
    let param_name = if col.name.length() > 0 {
      to_snake_case(col.name)
    } else {
      "p" + param.number.to_string()
    }
    buf.write_string("  ")
    buf.write_string(param_name)
    buf.write_string(" : ")
    buf.write_string(sql_type_to_moonbit(col))
    buf.write_string("\n")
  }
  buf.write_string("} derive(Show, Eq)\n\n")

  // Generate constructor function
  buf.write_string("///|\npub fn ")
  buf.write_string(name)
  buf.write_string("::new(")
  for i, param in params {
    let col = param.column
    let param_name = if col.name.length() > 0 {
      to_snake_case(col.name)
    } else {
      "p" + param.number.to_string()
    }
    if i > 0 {
      buf.write_string(", ")
    }
    buf.write_string(param_name)
    buf.write_string(" : ")
    buf.write_string(sql_type_to_moonbit(col))
  }
  buf.write_string(") -> ")
  buf.write_string(name)
  buf.write_string(" {\n")
  buf.write_string("  { ")
  for i, param in params {
    let col = param.column
    let param_name = if col.name.length() > 0 {
      to_snake_case(col.name)
    } else {
      "p" + param.number.to_string()
    }
    if i > 0 {
      buf.write_string(", ")
    }
    buf.write_string(param_name)
  }
  buf.write_string(" }\n")
  buf.write_string("}\n\n")
}

///|
fn generate_query_function(buf : StringBuilder, query : @plugin.Query) -> Unit {
  let func_name = to_snake_case(query.name)
  let sql_const = to_snake_case(query.name) + "_sql"
  let row_type = to_pascal_case(query.name) + "Row"

  // Return type with error handling
  let return_type = match query.cmd {
    ":one" => row_type + "?"
    ":many" => "Array[" + row_type + "]"
    _ => "Unit"
  }

  // Doc comment
  buf.write_string("///| ")
  buf.write_string(query.name)
  buf.write_string("\n")
  buf.write_string("/// ")
  buf.write_string(query.text.replace(old="\n", new=" "))
  buf.write_string("\n")

  // Function signature - use low-level Sqlite3 type
  buf.write_string("pub fn ")
  buf.write_string(func_name)
  buf.write_string("(db : @sqlite.Sqlite3")
  if query.params.length() > 0 {
    buf.write_string(", params : ")
    buf.write_string(to_pascal_case(query.name))
    buf.write_string("Params")
  }
  buf.write_string(") -> ")
  buf.write_string(return_type)
  buf.write_string(" {\n")

  // Prepare statement using low-level API
  buf.write_string("  let stmt = @sqlite.sqlite_prepare(db, cstring(")
  buf.write_string(sql_const)
  buf.write_string("))\n")

  // Bind parameters using low-level sqlite_bind_* functions
  if query.params.length() > 0 {
    for i, param in query.params {
      let col = param.column
      let param_name = if col.name.length() > 0 {
        to_snake_case(col.name)
      } else {
        "p" + param.number.to_string()
      }
      buf.write_string("  ")
      buf.write_string(param_to_bind_call(col, i + 1, "params." + param_name))
      buf.write_string(" |> ignore\n")
    }
  }

  // Execute based on command type using low-level API
  match query.cmd {
    ":one" => {
      buf.write_string("  if @sqlite.sqlite_step(stmt) == @sqlite.SQLITE_ROW {\n")
      buf.write_string("    let row : ")
      buf.write_string(row_type)
      buf.write_string(" = {\n")
      for i, col in query.columns {
        buf.write_string("      ")
        buf.write_string(to_snake_case(col.name))
        buf.write_string(": ")
        buf.write_string(column_to_moonbit(col, i))
        buf.write_string(",\n")
      }
      buf.write_string("    }\n")
      buf.write_string("    @sqlite.sqlite_finalize(stmt)\n")
      buf.write_string("    Some(row)\n")
      buf.write_string("  } else {\n")
      buf.write_string("    @sqlite.sqlite_finalize(stmt)\n")
      buf.write_string("    None\n")
      buf.write_string("  }\n")
    }
    ":many" => {
      buf.write_string("  let results : Array[")
      buf.write_string(row_type)
      buf.write_string("] = []\n")
      buf.write_string("  while @sqlite.sqlite_step(stmt) == @sqlite.SQLITE_ROW {\n")
      buf.write_string("    let row : ")
      buf.write_string(row_type)
      buf.write_string(" = {\n")
      for i, col in query.columns {
        buf.write_string("      ")
        buf.write_string(to_snake_case(col.name))
        buf.write_string(": ")
        buf.write_string(column_to_moonbit(col, i))
        buf.write_string(",\n")
      }
      buf.write_string("    }\n")
      buf.write_string("    results.push(row)\n")
      buf.write_string("  }\n")
      buf.write_string("  @sqlite.sqlite_finalize(stmt)\n")
      buf.write_string("  results\n")
    }
    _ => {
      // :exec
      buf.write_string("  @sqlite.sqlite_step(stmt) |> ignore\n")
      buf.write_string("  @sqlite.sqlite_finalize(stmt)\n")
    }
  }

  buf.write_string("}\n\n")
}

///|
fn param_to_bind_call(col : @plugin.Column, idx : Int, expr : String) -> String {
  let type_name = col.type_.name.to_upper()
  let idx_str = idx.to_string()
  match type_name {
    "INTEGER" | "INT" | "INT4" | "SMALLINT" =>
      "@sqlite.sqlite_bind_int(stmt, " + idx_str + ", " + expr + ".to_int())"
    "INT8" | "BIGINT" =>
      "@sqlite.sqlite_bind_int64(stmt, " + idx_str + ", " + expr + ")"
    "REAL" | "FLOAT" | "DOUBLE" | "NUMERIC" | "DECIMAL" =>
      "@sqlite.sqlite_bind_double(stmt, " + idx_str + ", " + expr + ")"
    "TEXT" | "VARCHAR" | "CHAR" | "CHARACTER" | "CLOB" =>
      "@sqlite.sqlite_bind_text(stmt, " + idx_str + ", cstring(" + expr + "))"
    "BLOB" | "BYTEA" =>
      "@sqlite.sqlite_bind_blob(stmt, " + idx_str + ", " + expr + ")"
    "BOOLEAN" | "BOOL" =>
      "@sqlite.sqlite_bind_int(stmt, " + idx_str + ", if " + expr + " { 1 } else { 0 })"
    _ =>
      "@sqlite.sqlite_bind_text(stmt, " + idx_str + ", cstring(" + expr + "))"
  }
}

///|
fn column_to_moonbit(col : @plugin.Column, idx : Int) -> String {
  let type_name = col.type_.name.to_upper()
  let idx_str = idx.to_string()
  match type_name {
    "INTEGER" | "INT" | "INT4" | "INT8" | "BIGINT" | "SMALLINT" =>
      "@sqlite.sqlite_column_int64(stmt, " + idx_str + ")"
    "REAL" | "FLOAT" | "DOUBLE" | "NUMERIC" | "DECIMAL" =>
      "@sqlite.sqlite_column_double(stmt, " + idx_str + ")"
    "TEXT" | "VARCHAR" | "CHAR" | "CHARACTER" | "CLOB" =>
      "bytes_to_string(@sqlite.sqlite_column_text(stmt, " + idx_str + "))"
    "BLOB" | "BYTEA" =>
      "@sqlite.sqlite_column_blob(stmt, " + idx_str + ")"
    "BOOLEAN" | "BOOL" =>
      "@sqlite.sqlite_column_int(stmt, " + idx_str + ") != 0"
    _ =>
      "bytes_to_string(@sqlite.sqlite_column_text(stmt, " + idx_str + "))"
  }
}

///|
fn sql_type_to_moonbit(col : @plugin.Column) -> String {
  let type_name = col.type_.name.to_upper()
  let base_type = match type_name {
    "INTEGER" | "INT" | "INT4" | "INT8" | "BIGINT" | "SMALLINT" => "Int64"
    "REAL" | "FLOAT" | "DOUBLE" | "NUMERIC" | "DECIMAL" => "Double"
    "TEXT" | "VARCHAR" | "CHAR" | "CHARACTER" | "CLOB" => "String"
    "BLOB" | "BYTEA" => "Bytes"
    "BOOLEAN" | "BOOL" => "Bool"
    _ => "String"  // Default to String for unknown types
  }

  if col.not_null {
    if col.is_array {
      "Array[" + base_type + "]"
    } else {
      base_type
    }
  } else {
    if col.is_array {
      "Array[" + base_type + "]?"
    } else {
      base_type + "?"
    }
  }
}

///|
fn to_pascal_case(s : String) -> String {
  let buf = StringBuilder::new()
  let mut capitalize_next = true
  for c in s {
    if c == '_' || c == '-' {
      capitalize_next = true
    } else if capitalize_next {
      buf.write_char(to_upper_char(c))
      capitalize_next = false
    } else {
      buf.write_char(c)
    }
  }
  buf.to_string()
}

///|
fn to_snake_case(s : String) -> String {
  let buf = StringBuilder::new()
  let mut prev_lower = false
  for c in s {
    if is_upper(c) {
      if prev_lower {
        buf.write_char('_')
      }
      buf.write_char(to_lower_char(c))
      prev_lower = false
    } else {
      buf.write_char(c)
      prev_lower = is_lower(c)
    }
  }
  buf.to_string()
}

///|
fn to_upper_char(c : Char) -> Char {
  if c >= 'a' && c <= 'z' {
    (c.to_int() - 32).unsafe_to_char()
  } else {
    c
  }
}

///|
fn to_lower_char(c : Char) -> Char {
  if c >= 'A' && c <= 'Z' {
    (c.to_int() + 32).unsafe_to_char()
  } else {
    c
  }
}

///|
fn is_upper(c : Char) -> Bool {
  c >= 'A' && c <= 'Z'
}

///|
fn is_lower(c : Char) -> Bool {
  c >= 'a' && c <= 'z'
}

///|
fn escape_string(s : String) -> String {
  let buf = StringBuilder::new()
  buf.write_char('"')
  for c in s {
    match c {
      '"' => buf.write_string("\\\"")
      '\\' => buf.write_string("\\\\")
      '\n' => buf.write_string("\\n")
      '\r' => buf.write_string("\\r")
      '\t' => buf.write_string("\\t")
      _ => buf.write_char(c)
    }
  }
  buf.write_char('"')
  buf.to_string()
}

///|
fn serialize_response(response : @plugin.GenerateResponse) -> Bytes {
  // Calculate size
  let size = @protobuf.size_of(response)
  let buf = FixedArray::makei(size.reinterpret_as_int(), fn(_i) { b'\x00' })
  let mut offset = 0
  
  // Write each file
  for file in response.files {
    // Tag for files field (field 1, wire type 2 = length-delimited)
    buf[offset] = b'\x0a'
    offset += 1
    
    // Calculate file message size
    let file_size = @protobuf.size_of(file)
    
    // Write file size as varint
    let mut sz = file_size
    while sz >= 0x80U {
      buf[offset] = (sz.land(0x7FU).lor(0x80U)).to_byte()
      offset += 1
      sz = sz >> 7
    }
    buf[offset] = sz.to_byte()
    offset += 1
    
    // Write name field (field 1)
    buf[offset] = b'\x0a'
    offset += 1
    let name_bytes = string_to_utf8(file.name)
    let name_len = name_bytes.length()
    let mut nl = name_len.reinterpret_as_uint()
    while nl >= 0x80U {
      buf[offset] = (nl.land(0x7FU).lor(0x80U)).to_byte()
      offset += 1
      nl = nl >> 7
    }
    buf[offset] = nl.to_byte()
    offset += 1
    for i in 0..<name_len {
      buf[offset] = name_bytes[i]
      offset += 1
    }
    
    // Write contents field (field 2)
    buf[offset] = b'\x12'
    offset += 1
    let contents = file.contents
    let contents_len = contents.length()
    let mut cl = contents_len.reinterpret_as_uint()
    while cl >= 0x80U {
      buf[offset] = (cl.land(0x7FU).lor(0x80U)).to_byte()
      offset += 1
      cl = cl >> 7
    }
    buf[offset] = cl.to_byte()
    offset += 1
    for i in 0..<contents_len {
      buf[offset] = contents[i]
      offset += 1
    }
  }
  
  let result : Array[Byte] = []
  for i in 0..<offset {
    result.push(buf[i])
  }
  Bytes::from_array(result)
}

///|
fn string_to_utf8(s : String) -> Bytes {
  let arr : Array[Byte] = []
  for c in s {
    let code = c.to_uint()
    if code < 0x80U {
      arr.push(code.to_byte())
    } else if code < 0x800U {
      arr.push((0xC0U.lor(code >> 6)).to_byte())
      arr.push((0x80U.lor(code.land(0x3FU))).to_byte())
    } else if code < 0x10000U {
      arr.push((0xE0U.lor(code >> 12)).to_byte())
      arr.push((0x80U.lor((code >> 6).land(0x3FU))).to_byte())
      arr.push((0x80U.lor(code.land(0x3FU))).to_byte())
    } else {
      arr.push((0xF0U.lor(code >> 18)).to_byte())
      arr.push((0x80U.lor((code >> 12).land(0x3FU))).to_byte())
      arr.push((0x80U.lor((code >> 6).land(0x3FU))).to_byte())
      arr.push((0x80U.lor(code.land(0x3FU))).to_byte())
    }
  }
  Bytes::from_iter(arr.iter())
}

///|
fn read_all_stdin() -> Bytes {
  // Use C FFI to read all data from stdin
  let size = moonbit_read_stdin_size()
  if size <= 0L {
    Bytes::new(0)
  } else {
    let buffer = Bytes::make(size.to_int(), 0)
    moonbit_copy_stdin_data(buffer)
    buffer
  }
}

///|
fn write_all_stdout(data : Bytes) -> Unit {
  let _ = moonbit_write_all_stdout(data, data.length().to_int64())
}
