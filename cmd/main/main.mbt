///|
fn async_run(f : async () -> Unit noraise) -> Unit = "%async.run"

// Backend types
///|
pub enum Backend {
  Sqlite
  D1
}

///|
pub fn Backend::to_string(self : Backend) -> String {
  match self {
    Sqlite => "sqlite"
    D1 => "d1"
  }
}

// Plugin options
///|
pub struct Options {
  backend : Backend
}

///|
pub fn Options::default() -> Options {
  { backend: Sqlite }
}

///|
fn parse_plugin_options(data : Bytes) -> Options {
  if data.length() == 0 {
    return Options::default()
  }
  // Parse JSON-like format: {"backend":"d1"}
  let json_str = bytes_to_string_simple(data)
  let backend = if json_str.contains("\"d1\"") {
    D1
  } else {
    Sqlite
  }
  { backend, }
}

///|
fn bytes_to_string_simple(b : Bytes) -> String {
  let buf = StringBuilder::new()
  for i = 0; i < b.length(); i = i + 1 {
    let byte = b[i]
    if byte >= 32 && byte < 127 {
      buf.write_char(byte.to_int().unsafe_to_char())
    }
  }
  buf.to_string()
}

// FFI declarations for native stdin/stdout handling
///|
extern "C" fn moonbit_read_stdin_size() -> Int64 = "moonbit_read_stdin_size"

///|
#borrow(dest)
extern "C" fn moonbit_copy_stdin_data(dest : Bytes) -> Unit = "moonbit_copy_stdin_data"

///|
#borrow(data)
extern "C" fn moonbit_write_all_stdout(data : Bytes, len : Int64) -> Int = "moonbit_write_all_stdout"

///|
#borrow(data)
extern "C" fn moonbit_write_stderr(data : Bytes, len : Int64) -> Int = "moonbit_write_stderr"

///|
fn main {
  // Read stdin
  let input = read_all_stdin()

  // Parse GenerateRequest from protobuf
  let reader = @protobuf.BytesReader::from_bytes(input)
  let mut request = @plugin.GenerateRequest::default()
  async_run(async fn() -> Unit noraise {
    request = @protobuf.AsyncRead::read(reader) catch {
      err => {
        write_stderr("Parse error: " + err.to_string() + "\n")
        @plugin.GenerateRequest::default()
      }
    }
  })

  // Parse plugin options
  let options = parse_plugin_options(request.plugin_options)

  // Generate code - 2 files: types and queries
  let files : Array[@plugin.File] = []

  // Generate types (common for all backends)
  let types_content = generate_types(request)
  files.push(@plugin.File::new("sqlc_types.mbt", string_to_utf8(types_content)))

  // Generate queries (backend-specific)
  let queries_content = match options.backend {
    Sqlite => generate_queries_sqlite(request)
    D1 => generate_queries_d1(request)
  }
  files.push(@plugin.File::new("sqlc_queries.mbt", string_to_utf8(queries_content)))

  let response = @plugin.GenerateResponse::new(files)

  // Serialize response to protobuf and write to stdout
  let output = serialize_response(response)
  write_all_stdout(output)
}

///|
fn write_stderr(msg : String) -> Unit {
  let bytes = string_to_utf8(msg)
  let _ = moonbit_write_stderr(bytes, bytes.length().to_int64())
}

///|
fn generate_types(request : @plugin.GenerateRequest) -> String {
  let buf = StringBuilder::new()
  buf.write_string("// Generated by sqlc-gen-moonbit\n")
  buf.write_string("// sqlc version: ")
  buf.write_string(request.sqlc_version)
  buf.write_string("\n\n")

  // Collect unique result structs from queries
  let generated_structs : Map[String, Bool] = {}

  // Generate result structs for queries that return data
  for query in request.queries {
    if query.cmd == ":one" || query.cmd == ":many" {
      let struct_name = to_pascal_case(query.name) + "Row"
      if not(generated_structs.contains(struct_name)) && query.columns.length() > 0 {
        generated_structs[struct_name] = true
        generate_result_struct(buf, struct_name, query.columns)
      }
    }
  }

  // Generate parameter structs for queries with parameters
  for query in request.queries {
    if query.params.length() > 0 {
      let struct_name = to_pascal_case(query.name) + "Params"
      generate_params_struct(buf, struct_name, query.params)
    }
  }

  // Generate SQL constants
  buf.write_string("// SQL queries\n")
  for query in request.queries {
    let const_name = to_snake_case(query.name) + "_sql"
    buf.write_string("pub let ")
    buf.write_string(const_name)
    buf.write_string(" : String = ")
    buf.write_string(escape_string(query.text))
    buf.write_string("\n\n")
  }

  buf.to_string()
}

///|
fn generate_queries_sqlite(request : @plugin.GenerateRequest) -> String {
  let buf = StringBuilder::new()
  buf.write_string("// Generated by sqlc-gen-moonbit (backend: sqlite)\n\n")

  // Generate helper functions for SQLite
  buf.write_string("///|\nfn cstring(s : String) -> Bytes {\n")
  buf.write_string("  @encoding.encode(@encoding.UTF8, s)\n")
  buf.write_string("}\n\n")
  buf.write_string("///|\nfn bytes_to_string(b : Bytes) -> String {\n")
  buf.write_string("  let decoder = @encoding.decoder(@encoding.UTF8)\n")
  buf.write_string("  decoder.decode_lossy(b[0:b.length()])\n")
  buf.write_string("}\n\n")

  // Generate query functions
  buf.write_string("// Query functions\n")
  for query in request.queries {
    generate_query_function_sqlite(buf, query)
  }

  buf.to_string()
}

///|
fn generate_queries_d1(request : @plugin.GenerateRequest) -> String {
  let buf = StringBuilder::new()
  buf.write_string("// Generated by sqlc-gen-moonbit (backend: d1)\n")
  buf.write_string("// Requires: mizchi/cloudflare\n\n")

  // Generate query functions using cloudflare.mbt D1 types
  buf.write_string("// Query functions\n")
  for query in request.queries {
    generate_query_function_d1(buf, query)
  }

  buf.to_string()
}

///|
fn generate_d1_bind_function(buf : StringBuilder, n : Int) -> Unit {
  buf.write_string("extern \"js\" fn d1_bind")
  buf.write_string(n.to_string())
  buf.write_string("(stmt : @js.Any")
  for i = 1; i <= n; i = i + 1 {
    buf.write_string(", p")
    buf.write_string(i.to_string())
    buf.write_string(" : @js.Any")
  }
  buf.write_string(") -> @js.Any =\n")
  buf.write_string("  #| (stmt")
  for i = 1; i <= n; i = i + 1 {
    buf.write_string(", p")
    buf.write_string(i.to_string())
  }
  buf.write_string(") => stmt.bind(")
  for i = 1; i <= n; i = i + 1 {
    if i > 1 {
      buf.write_string(", ")
    }
    buf.write_string("p")
    buf.write_string(i.to_string())
  }
  buf.write_string(")\n\n")
}

///|
fn generate_result_struct(
  buf : StringBuilder,
  name : String,
  columns : Array[@plugin.Column]
) -> Unit {
  buf.write_string("///|\npub struct ")
  buf.write_string(name)
  buf.write_string(" {\n")
  for col in columns {
    buf.write_string("  ")
    buf.write_string(to_snake_case(col.name))
    buf.write_string(" : ")
    buf.write_string(sql_type_to_moonbit(col))
    buf.write_string("\n")
  }
  buf.write_string("} derive(Show, Eq)\n\n")
}

///|
fn generate_params_struct(
  buf : StringBuilder,
  name : String,
  params : Array[@plugin.Parameter]
) -> Unit {
  buf.write_string("///|\npub struct ")
  buf.write_string(name)
  buf.write_string(" {\n")
  for param in params {
    let col = param.column
    let param_name = if col.name.length() > 0 {
      to_snake_case(col.name)
    } else {
      "p" + param.number.to_string()
    }
    buf.write_string("  ")
    buf.write_string(param_name)
    buf.write_string(" : ")
    buf.write_string(sql_type_to_moonbit(col))
    buf.write_string("\n")
  }
  buf.write_string("} derive(Show, Eq)\n\n")

  // Generate constructor function
  buf.write_string("///|\npub fn ")
  buf.write_string(name)
  buf.write_string("::new(")
  for i, param in params {
    let col = param.column
    let param_name = if col.name.length() > 0 {
      to_snake_case(col.name)
    } else {
      "p" + param.number.to_string()
    }
    if i > 0 {
      buf.write_string(", ")
    }
    buf.write_string(param_name)
    buf.write_string(" : ")
    buf.write_string(sql_type_to_moonbit(col))
  }
  buf.write_string(") -> ")
  buf.write_string(name)
  buf.write_string(" {\n")
  buf.write_string("  { ")
  for i, param in params {
    let col = param.column
    let param_name = if col.name.length() > 0 {
      to_snake_case(col.name)
    } else {
      "p" + param.number.to_string()
    }
    if i > 0 {
      buf.write_string(", ")
    }
    buf.write_string(param_name)
  }
  buf.write_string(", }\n")
  buf.write_string("}\n\n")
}

///|
fn generate_query_function_sqlite(buf : StringBuilder, query : @plugin.Query) -> Unit {
  let func_name = to_snake_case(query.name)
  let sql_const = to_snake_case(query.name) + "_sql"
  let row_type = to_pascal_case(query.name) + "Row"

  // Return type with error handling
  let return_type = match query.cmd {
    ":one" => row_type + "?"
    ":many" => "Array[" + row_type + "]"
    _ => "Unit"
  }

  // Doc comment
  buf.write_string("///| ")
  buf.write_string(query.name)
  buf.write_string("\n")
  buf.write_string("/// ")
  buf.write_string(sanitize_newlines(query.text))
  buf.write_string("\n")

  // Function signature - use low-level Sqlite3 type
  buf.write_string("pub fn ")
  buf.write_string(func_name)
  buf.write_string("(db : @sqlite.Sqlite3")
  if query.params.length() > 0 {
    buf.write_string(", params : ")
    buf.write_string(to_pascal_case(query.name))
    buf.write_string("Params")
  }
  buf.write_string(") -> ")
  buf.write_string(return_type)
  buf.write_string(" {\n")

  // Prepare statement using low-level API
  buf.write_string("  let stmt = @sqlite.sqlite_prepare(db, cstring(")
  buf.write_string(sql_const)
  buf.write_string("))\n")

  // Bind parameters using low-level sqlite_bind_* functions
  if query.params.length() > 0 {
    for i, param in query.params {
      let col = param.column
      let param_name = if col.name.length() > 0 {
        to_snake_case(col.name)
      } else {
        "p" + param.number.to_string()
      }
      buf.write_string("  ")
      buf.write_string(param_to_bind_call(col, i + 1, "params." + param_name))
      buf.write_string(" |> ignore\n")
    }
  }

  // Execute based on command type using low-level API
  match query.cmd {
    ":one" => {
      buf.write_string("  if @sqlite.sqlite_step(stmt) == @sqlite.SQLITE_ROW {\n")
      buf.write_string("    let row : ")
      buf.write_string(row_type)
      buf.write_string(" = {\n")
      for i, col in query.columns {
        buf.write_string("      ")
        buf.write_string(to_snake_case(col.name))
        buf.write_string(": ")
        buf.write_string(column_to_moonbit(col, i))
        buf.write_string(",\n")
      }
      buf.write_string("    }\n")
      buf.write_string("    @sqlite.sqlite_finalize(stmt)\n")
      buf.write_string("    Some(row)\n")
      buf.write_string("  } else {\n")
      buf.write_string("    @sqlite.sqlite_finalize(stmt)\n")
      buf.write_string("    None\n")
      buf.write_string("  }\n")
    }
    ":many" => {
      buf.write_string("  let results : Array[")
      buf.write_string(row_type)
      buf.write_string("] = []\n")
      buf.write_string("  while @sqlite.sqlite_step(stmt) == @sqlite.SQLITE_ROW {\n")
      buf.write_string("    let row : ")
      buf.write_string(row_type)
      buf.write_string(" = {\n")
      for i, col in query.columns {
        buf.write_string("      ")
        buf.write_string(to_snake_case(col.name))
        buf.write_string(": ")
        buf.write_string(column_to_moonbit(col, i))
        buf.write_string(",\n")
      }
      buf.write_string("    }\n")
      buf.write_string("    results.push(row)\n")
      buf.write_string("  }\n")
      buf.write_string("  @sqlite.sqlite_finalize(stmt)\n")
      buf.write_string("  results\n")
    }
    _ => {
      // :exec
      buf.write_string("  @sqlite.sqlite_step(stmt) |> ignore\n")
      buf.write_string("  @sqlite.sqlite_finalize(stmt)\n")
    }
  }

  buf.write_string("}\n\n")
}

///|
fn generate_query_function_d1(buf : StringBuilder, query : @plugin.Query) -> Unit {
  let func_name = to_snake_case(query.name)
  let sql_const = to_snake_case(query.name) + "_sql"
  let row_type = to_pascal_case(query.name) + "Row"
  let param_count = query.params.length()

  // Return type with async
  let return_type = match query.cmd {
    ":one" => row_type + "?"
    ":many" => "Array[" + row_type + "]"
    _ => "Unit"
  }

  // Doc comment
  buf.write_string("///| ")
  buf.write_string(query.name)
  buf.write_string("\n")
  buf.write_string("/// ")
  buf.write_string(sanitize_newlines(query.text))
  buf.write_string("\n")

  // Function signature - async with D1Database type from cloudflare.mbt
  buf.write_string("pub async fn ")
  buf.write_string(func_name)
  buf.write_string("(db : @cloudflare.D1Database")
  if param_count > 0 {
    buf.write_string(", params : ")
    buf.write_string(to_pascal_case(query.name))
    buf.write_string("Params")
  }
  buf.write_string(") -> ")
  buf.write_string(return_type)
  buf.write_string(" {\n")

  // Prepare and bind statement using cloudflare.mbt API
  buf.write_string("  let stmt = db.prepare(")
  buf.write_string(sql_const)
  buf.write_string(")")
  if param_count > 0 {
    buf.write_string(".bind([")
    for i, param in query.params {
      let col = param.column
      let param_name = if col.name.length() > 0 {
        to_snake_case(col.name)
      } else {
        "p" + param.number.to_string()
      }
      if i > 0 {
        buf.write_string(", ")
      }
      buf.write_string(param_to_core_any(col, "params." + param_name))
    }
    buf.write_string("])")
  }
  buf.write_string("\n")

  // Execute based on command type
  match query.cmd {
    ":one" => {
      buf.write_string("  match stmt.first() {\n")
      buf.write_string("    None => None\n")
      buf.write_string("    Some(result) => Some({\n")
      for col in query.columns {
        buf.write_string("      ")
        buf.write_string(to_snake_case(col.name))
        buf.write_string(": ")
        buf.write_string(column_from_core_any(col, "result"))
        buf.write_string(",\n")
      }
      buf.write_string("    })\n")
      buf.write_string("  }\n")
    }
    ":many" => {
      buf.write_string("  let d1_result = stmt.all()\n")
      buf.write_string("  let results_arr = d1_result.get_results()\n")
      buf.write_string("  let results : Array[")
      buf.write_string(row_type)
      buf.write_string("] = []\n")
      buf.write_string("  for row in results_arr {\n")
      buf.write_string("    results.push({\n")
      for col in query.columns {
        buf.write_string("      ")
        buf.write_string(to_snake_case(col.name))
        buf.write_string(": ")
        buf.write_string(column_from_core_any(col, "row"))
        buf.write_string(",\n")
      }
      buf.write_string("    })\n")
      buf.write_string("  }\n")
      buf.write_string("  results\n")
    }
    _ => {
      // :exec
      buf.write_string("  stmt.run() |> ignore\n")
    }
  }

  buf.write_string("}\n\n")
}

///|
fn param_to_js_any(col : @plugin.Column, expr : String) -> String {
  let type_name = col.type_.name.to_upper()
  // For nullable types, we need to handle Option
  let is_nullable = not(col.not_null)
  if is_nullable {
    // For nullable params, use match to handle None
    match type_name {
      "INTEGER" | "INT" | "INT4" | "SMALLINT" =>
        "(match " + expr + " { Some(v) => @js.any(v.to_int()); None => js_null() })"
      _ =>
        "(match " + expr + " { Some(v) => @js.any(v); None => js_null() })"
    }
  } else {
    match type_name {
      "INTEGER" | "INT" | "INT4" | "SMALLINT" =>
        "@js.any(" + expr + ".to_int())"
      "INT8" | "BIGINT" =>
        "@js.any(" + expr + ")"
      "REAL" | "FLOAT" | "DOUBLE" | "NUMERIC" | "DECIMAL" =>
        "@js.any(" + expr + ")"
      "TEXT" | "VARCHAR" | "CHAR" | "CHARACTER" | "CLOB" =>
        "@js.any(" + expr + ")"
      "BOOLEAN" | "BOOL" =>
        "@js.any(" + expr + ")"
      _ =>
        "@js.any(" + expr + ".to_string())"
    }
  }
}

///|
fn param_to_core_any(col : @plugin.Column, expr : String) -> String {
  let type_name = col.type_.name.to_upper()
  // For nullable types, we need to handle Option
  let is_nullable = not(col.not_null)
  if is_nullable {
    // For nullable params, use match to handle None - @core.null() for null value
    match type_name {
      "INTEGER" | "INT" | "INT4" | "SMALLINT" =>
        "(match " + expr + " { Some(v) => @core.any(v.to_int()); None => @core.null() })"
      _ =>
        "(match " + expr + " { Some(v) => @core.any(v); None => @core.null() })"
    }
  } else {
    match type_name {
      "INTEGER" | "INT" | "INT4" | "SMALLINT" =>
        "@core.any(" + expr + ".to_int())"
      "INT8" | "BIGINT" =>
        "@core.any(" + expr + ")"
      "REAL" | "FLOAT" | "DOUBLE" | "NUMERIC" | "DECIMAL" =>
        "@core.any(" + expr + ")"
      "TEXT" | "VARCHAR" | "CHAR" | "CHARACTER" | "CLOB" =>
        "@core.any(" + expr + ")"
      "BOOLEAN" | "BOOL" =>
        "@core.any(" + expr + ")"
      _ =>
        "@core.any(" + expr + ".to_string())"
    }
  }
}

///|
fn column_from_js_any(col : @plugin.Column, obj_expr : String) -> String {
  let type_name = col.type_.name.to_upper()
  let field_name = "\"" + col.name + "\""
  match type_name {
    "INTEGER" | "INT" | "INT4" | "INT8" | "BIGINT" | "SMALLINT" =>
      obj_expr + "[" + field_name + "].cast()"
    "REAL" | "FLOAT" | "DOUBLE" | "NUMERIC" | "DECIMAL" =>
      obj_expr + "[" + field_name + "].cast()"
    "TEXT" | "VARCHAR" | "CHAR" | "CHARACTER" | "CLOB" =>
      obj_expr + "[" + field_name + "].cast()"
    "BOOLEAN" | "BOOL" =>
      obj_expr + "[" + field_name + "].cast()"
    _ =>
      obj_expr + "[" + field_name + "].cast()"
  }
}

///|
fn column_from_core_any(col : @plugin.Column, obj_expr : String) -> String {
  let type_name = col.type_.name.to_upper()
  let field_name = "\"" + col.name + "\""
  // Access field from @core.Any using subscript and cast
  match type_name {
    "INTEGER" | "INT" | "INT4" | "INT8" | "BIGINT" | "SMALLINT" =>
      obj_expr + "[" + field_name + "].cast()"
    "REAL" | "FLOAT" | "DOUBLE" | "NUMERIC" | "DECIMAL" =>
      obj_expr + "[" + field_name + "].cast()"
    "TEXT" | "VARCHAR" | "CHAR" | "CHARACTER" | "CLOB" =>
      obj_expr + "[" + field_name + "].cast()"
    "BOOLEAN" | "BOOL" =>
      obj_expr + "[" + field_name + "].cast()"
    _ =>
      obj_expr + "[" + field_name + "].cast()"
  }
}

///|
fn param_to_bind_call(col : @plugin.Column, idx : Int, expr : String) -> String {
  let type_name = col.type_.name.to_upper()
  let idx_str = idx.to_string()
  match type_name {
    "INTEGER" | "INT" | "INT4" | "SMALLINT" =>
      "@sqlite.sqlite_bind_int(stmt, " + idx_str + ", " + expr + ".to_int())"
    "INT8" | "BIGINT" =>
      "@sqlite.sqlite_bind_int64(stmt, " + idx_str + ", " + expr + ")"
    "REAL" | "FLOAT" | "DOUBLE" | "NUMERIC" | "DECIMAL" =>
      "@sqlite.sqlite_bind_double(stmt, " + idx_str + ", " + expr + ")"
    "TEXT" | "VARCHAR" | "CHAR" | "CHARACTER" | "CLOB" =>
      "@sqlite.sqlite_bind_text(stmt, " + idx_str + ", cstring(" + expr + "))"
    "BLOB" | "BYTEA" =>
      "@sqlite.sqlite_bind_blob(stmt, " + idx_str + ", " + expr + ")"
    "BOOLEAN" | "BOOL" =>
      "@sqlite.sqlite_bind_int(stmt, " + idx_str + ", if " + expr + " { 1 } else { 0 })"
    _ =>
      "@sqlite.sqlite_bind_text(stmt, " + idx_str + ", cstring(" + expr + "))"
  }
}

///|
fn column_to_moonbit(col : @plugin.Column, idx : Int) -> String {
  let type_name = col.type_.name.to_upper()
  let idx_str = idx.to_string()
  match type_name {
    "INTEGER" | "INT" | "INT4" | "INT8" | "BIGINT" | "SMALLINT" =>
      "@sqlite.sqlite_column_int64(stmt, " + idx_str + ")"
    "REAL" | "FLOAT" | "DOUBLE" | "NUMERIC" | "DECIMAL" =>
      "@sqlite.sqlite_column_double(stmt, " + idx_str + ")"
    "TEXT" | "VARCHAR" | "CHAR" | "CHARACTER" | "CLOB" =>
      "bytes_to_string(@sqlite.sqlite_column_text(stmt, " + idx_str + "))"
    "BLOB" | "BYTEA" =>
      "@sqlite.sqlite_column_blob(stmt, " + idx_str + ")"
    "BOOLEAN" | "BOOL" =>
      "@sqlite.sqlite_column_int(stmt, " + idx_str + ") != 0"
    _ =>
      "bytes_to_string(@sqlite.sqlite_column_text(stmt, " + idx_str + "))"
  }
}

///|
fn sql_type_to_moonbit(col : @plugin.Column) -> String {
  let type_name = col.type_.name.to_upper()
  let base_type = match type_name {
    "INTEGER" | "INT" | "INT4" | "INT8" | "BIGINT" | "SMALLINT" => "Int64"
    "REAL" | "FLOAT" | "DOUBLE" | "NUMERIC" | "DECIMAL" => "Double"
    "TEXT" | "VARCHAR" | "CHAR" | "CHARACTER" | "CLOB" => "String"
    "BLOB" | "BYTEA" => "Bytes"
    "BOOLEAN" | "BOOL" => "Bool"
    _ => "String"  // Default to String for unknown types
  }

  if col.not_null {
    if col.is_array {
      "Array[" + base_type + "]"
    } else {
      base_type
    }
  } else {
    if col.is_array {
      "Array[" + base_type + "]?"
    } else {
      base_type + "?"
    }
  }
}

///|
fn to_pascal_case(s : String) -> String {
  let buf = StringBuilder::new()
  let mut capitalize_next = true
  for c in s {
    if c == '_' || c == '-' {
      capitalize_next = true
    } else if capitalize_next {
      buf.write_char(to_upper_char(c))
      capitalize_next = false
    } else {
      buf.write_char(c)
    }
  }
  buf.to_string()
}

///|
fn to_snake_case(s : String) -> String {
  let buf = StringBuilder::new()
  let mut prev_lower = false
  for c in s {
    if is_upper(c) {
      if prev_lower {
        buf.write_char('_')
      }
      buf.write_char(to_lower_char(c))
      prev_lower = false
    } else {
      buf.write_char(c)
      prev_lower = is_lower(c)
    }
  }
  buf.to_string()
}

///|
fn to_upper_char(c : Char) -> Char {
  if c >= 'a' && c <= 'z' {
    (c.to_int() - 32).unsafe_to_char()
  } else {
    c
  }
}

///|
fn to_lower_char(c : Char) -> Char {
  if c >= 'A' && c <= 'Z' {
    (c.to_int() + 32).unsafe_to_char()
  } else {
    c
  }
}

///|
fn is_upper(c : Char) -> Bool {
  c >= 'A' && c <= 'Z'
}

///|
fn is_lower(c : Char) -> Bool {
  c >= 'a' && c <= 'z'
}

///|
fn sanitize_newlines(s : String) -> String {
  let buf = StringBuilder::new()
  for c in s {
    match c {
      '\n' | '\r' => buf.write_char(' ')
      _ => buf.write_char(c)
    }
  }
  buf.to_string()
}

///|
fn escape_string(s : String) -> String {
  let buf = StringBuilder::new()
  buf.write_char('"')
  for c in s {
    match c {
      '"' => buf.write_string("\\\"")
      '\\' => buf.write_string("\\\\")
      '\n' => buf.write_string("\\n")
      '\r' => buf.write_string("\\r")
      '\t' => buf.write_string("\\t")
      _ => buf.write_char(c)
    }
  }
  buf.write_char('"')
  buf.to_string()
}

///|
fn serialize_response(response : @plugin.GenerateResponse) -> Bytes {
  // Use Array to accumulate bytes dynamically (no fixed size)
  let bytes : Array[Byte] = []

  // Write each file
  for file in response.files {
    // Tag for files field (field 1, wire type 2 = length-delimited)
    bytes.push(b'\x0a')

    // Calculate file message size
    let file_size = @protobuf.size_of(file)

    // Write file size as varint
    let mut sz = file_size
    while sz >= 0x80U {
      bytes.push((sz.land(0x7FU).lor(0x80U)).to_byte())
      sz = sz >> 7
    }
    bytes.push(sz.to_byte())

    // Write name field (field 1)
    bytes.push(b'\x0a')
    let name_bytes = string_to_utf8(file.name)
    let name_len = name_bytes.length()
    let mut nl = name_len.reinterpret_as_uint()
    while nl >= 0x80U {
      bytes.push((nl.land(0x7FU).lor(0x80U)).to_byte())
      nl = nl >> 7
    }
    bytes.push(nl.to_byte())
    for i in 0..<name_len {
      bytes.push(name_bytes[i])
    }

    // Write contents field (field 2)
    bytes.push(b'\x12')
    let contents = file.contents
    let contents_len = contents.length()
    let mut cl = contents_len.reinterpret_as_uint()
    while cl >= 0x80U {
      bytes.push((cl.land(0x7FU).lor(0x80U)).to_byte())
      cl = cl >> 7
    }
    bytes.push(cl.to_byte())
    for i in 0..<contents_len {
      bytes.push(contents[i])
    }
  }

  Bytes::from_array(bytes)
}

///|
fn string_to_utf8(s : String) -> Bytes {
  let arr : Array[Byte] = []
  for c in s {
    let code = c.to_uint()
    if code < 0x80U {
      arr.push(code.to_byte())
    } else if code < 0x800U {
      arr.push((0xC0U.lor(code >> 6)).to_byte())
      arr.push((0x80U.lor(code.land(0x3FU))).to_byte())
    } else if code < 0x10000U {
      arr.push((0xE0U.lor(code >> 12)).to_byte())
      arr.push((0x80U.lor((code >> 6).land(0x3FU))).to_byte())
      arr.push((0x80U.lor(code.land(0x3FU))).to_byte())
    } else {
      arr.push((0xF0U.lor(code >> 18)).to_byte())
      arr.push((0x80U.lor((code >> 12).land(0x3FU))).to_byte())
      arr.push((0x80U.lor((code >> 6).land(0x3FU))).to_byte())
      arr.push((0x80U.lor(code.land(0x3FU))).to_byte())
    }
  }
  Bytes::from_iter(arr.iter())
}

///|
fn read_all_stdin() -> Bytes {
  // Use C FFI to read all data from stdin
  let size = moonbit_read_stdin_size()
  if size <= 0L {
    Bytes::new(0)
  } else {
    let buffer = Bytes::make(size.to_int(), 0)
    moonbit_copy_stdin_data(buffer)
    buffer
  }
}

///|
fn write_all_stdout(data : Bytes) -> Unit {
  let _ = moonbit_write_all_stdout(data, data.length().to_int64())
}
