// Generated by sqlc-gen-moonbit
// sqlc version: v1.30.0

///|
fn cstring(s : String) -> Bytes {
  @encoding.encode(@encoding.UTF8, s)
}

///|
fn bytes_to_string(b : Bytes) -> String {
  let decoder = @encoding.decoder(@encoding.UTF8)
  decoder.decode_lossy(b[0:b.length()])
}

///|
pub struct GetUserRow {
  id : Int64
  name : String
  email : String
} derive(Show, Eq)

///|
pub struct ListUsersRow {
  id : Int64
  name : String
  email : String
} derive(Show, Eq)

///|
pub struct GetUserParams {
  id : Int64
} derive(Show, Eq)

///|
pub fn GetUserParams::new(id : Int64) -> GetUserParams {
  { id }
}

///|
pub struct CreateUserParams {
  name : String
  email : String
} derive(Show, Eq)

///|
pub fn CreateUserParams::new(name : String, email : String) -> CreateUserParams {
  { name, email }
}

// SQL queries
pub let get_user_sql : String = "SELECT id, name, email FROM users WHERE id = ?"

pub let list_users_sql : String = "SELECT id, name, email FROM users ORDER BY name"

pub let create_user_sql : String = "INSERT INTO users (name, email) VALUES (?, ?)"

// Query functions
///| GetUser
/// SELECT id, name, email FROM users WHERE id = ?
pub fn get_user(db : @sqlite.Sqlite3, params : GetUserParams) -> GetUserRow? {
  let stmt = @sqlite.sqlite_prepare(db, cstring(get_user_sql))
  @sqlite.sqlite_bind_int(stmt, 1, params.id.to_int()) |> ignore
  if @sqlite.sqlite_step(stmt) == @sqlite.SQLITE_ROW {
    let row : GetUserRow = {
      id: @sqlite.sqlite_column_int64(stmt, 0),
      name: bytes_to_string(@sqlite.sqlite_column_text(stmt, 1)),
      email: bytes_to_string(@sqlite.sqlite_column_text(stmt, 2)),
    }
    @sqlite.sqlite_finalize(stmt)
    Some(row)
  } else {
    @sqlite.sqlite_finalize(stmt)
    None
  }
}

///| ListUsers
/// SELECT id, name, email FROM users ORDER BY name
pub fn list_users(db : @sqlite.Sqlite3) -> Array[ListUsersRow] {
  let stmt = @sqlite.sqlite_prepare(db, cstring(list_users_sql))
  let results : Array[ListUsersRow] = []
  while @sqlite.sqlite_step(stmt) == @sqlite.SQLITE_ROW {
    let row : ListUsersRow = {
      id: @sqlite.sqlite_column_int64(stmt, 0),
      name: bytes_to_string(@sqlite.sqlite_column_text(stmt, 1)),
      email: bytes_to_string(@sqlite.sqlite_column_text(stmt, 2)),
    }
    results.push(row)
  }
  @sqlite.sqlite_finalize(stmt)
  results
}

///| CreateUser
/// INSERT INTO users (name, email) VALUES (?, ?)
pub fn create_user(db : @sqlite.Sqlite3, params : CreateUserParams) -> Unit {
  let stmt = @sqlite.sqlite_prepare(db, cstring(create_user_sql))
  @sqlite.sqlite_bind_text(stmt, 1, cstring(params.name)) |> ignore
  @sqlite.sqlite_bind_text(stmt, 2, cstring(params.email)) |> ignore
  @sqlite.sqlite_step(stmt) |> ignore
  @sqlite.sqlite_finalize(stmt)
}

