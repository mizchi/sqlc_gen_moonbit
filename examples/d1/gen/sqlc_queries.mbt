// Generated by sqlc-gen-moonbit (backend: d1)
// Requires: mizchi/cloudflare

// Query functions
///| GetUserById
///  SELECT id, username, email, display_name, bio, avatar_url, created_at, updated_at FROM users WHERE id = ?
pub async fn get_user_by_id(db : @cloudflare.D1Database, params : GetUserByIdParams) -> GetUserByIdRow? {
  let stmt = db.prepare(get_user_by_id_sql).bind([@core.any(params.id.to_int())])
  match stmt.first() {
    None => None
    Some(result) => Some({
      id: result["id"].cast(),
      username: result["username"].cast(),
      email: result["email"].cast(),
      display_name: result["display_name"].cast(),
      bio: result["bio"].cast(),
      avatar_url: result["avatar_url"].cast(),
      created_at: result["created_at"].cast(),
      updated_at: result["updated_at"].cast(),
    })
  }
}

///| GetUserByUsername
/// SELECT id, username, email, display_name, bio, avatar_url, created_at, updated_at FROM users WHERE username = ?
pub async fn get_user_by_username(db : @cloudflare.D1Database, params : GetUserByUsernameParams) -> GetUserByUsernameRow? {
  let stmt = db.prepare(get_user_by_username_sql).bind([@core.any(params.username)])
  match stmt.first() {
    None => None
    Some(result) => Some({
      id: result["id"].cast(),
      username: result["username"].cast(),
      email: result["email"].cast(),
      display_name: result["display_name"].cast(),
      bio: result["bio"].cast(),
      avatar_url: result["avatar_url"].cast(),
      created_at: result["created_at"].cast(),
      updated_at: result["updated_at"].cast(),
    })
  }
}

///| ListUsers
/// SELECT id, username, email, display_name, bio, avatar_url, created_at, updated_at FROM users ORDER BY created_at DESC
pub async fn list_users(db : @cloudflare.D1Database) -> Array[ListUsersRow] {
  let stmt = db.prepare(list_users_sql)
  let d1_result = stmt.all()
  let results_arr = d1_result.get_results()
  let results : Array[ListUsersRow] = []
  for row in results_arr {
    results.push({
      id: row["id"].cast(),
      username: row["username"].cast(),
      email: row["email"].cast(),
      display_name: row["display_name"].cast(),
      bio: row["bio"].cast(),
      avatar_url: row["avatar_url"].cast(),
      created_at: row["created_at"].cast(),
      updated_at: row["updated_at"].cast(),
    })
  }
  results
}

///| CreateUser
/// INSERT INTO users (username, email, display_name, bio, avatar_url) VALUES (?, ?, ?, ?, ?)
pub async fn create_user(db : @cloudflare.D1Database, params : CreateUserParams) -> Unit {
  let stmt = db.prepare(create_user_sql).bind([@core.any(params.username), @core.any(params.email), @core.any(params.display_name), (match params.bio { Some(v) => @core.any(v); None => @core.null() }), (match params.avatar_url { Some(v) => @core.any(v); None => @core.null() })])
  stmt.run() |> ignore
}

///| GetCategoryById
///  SELECT id, name, slug, description FROM categories WHERE id = ?
pub async fn get_category_by_id(db : @cloudflare.D1Database, params : GetCategoryByIdParams) -> GetCategoryByIdRow? {
  let stmt = db.prepare(get_category_by_id_sql).bind([@core.any(params.id.to_int())])
  match stmt.first() {
    None => None
    Some(result) => Some({
      id: result["id"].cast(),
      name: result["name"].cast(),
      slug: result["slug"].cast(),
      description: result["description"].cast(),
    })
  }
}

///| ListCategories
/// SELECT id, name, slug, description FROM categories ORDER BY name
pub async fn list_categories(db : @cloudflare.D1Database) -> Array[ListCategoriesRow] {
  let stmt = db.prepare(list_categories_sql)
  let d1_result = stmt.all()
  let results_arr = d1_result.get_results()
  let results : Array[ListCategoriesRow] = []
  for row in results_arr {
    results.push({
      id: row["id"].cast(),
      name: row["name"].cast(),
      slug: row["slug"].cast(),
      description: row["description"].cast(),
    })
  }
  results
}

///| CreateCategory
/// INSERT INTO categories (name, slug, description) VALUES (?, ?, ?)
pub async fn create_category(db : @cloudflare.D1Database, params : CreateCategoryParams) -> Unit {
  let stmt = db.prepare(create_category_sql).bind([@core.any(params.name), @core.any(params.slug), (match params.description { Some(v) => @core.any(v); None => @core.null() })])
  stmt.run() |> ignore
}

///| GetPostById
///  SELECT id, author_id, category_id, title, slug, content, excerpt, status, published_at, created_at, updated_at FROM posts WHERE id = ?
pub async fn get_post_by_id(db : @cloudflare.D1Database, params : GetPostByIdParams) -> GetPostByIdRow? {
  let stmt = db.prepare(get_post_by_id_sql).bind([@core.any(params.id.to_int())])
  match stmt.first() {
    None => None
    Some(result) => Some({
      id: result["id"].cast(),
      author_id: result["author_id"].cast(),
      category_id: result["category_id"].cast(),
      title: result["title"].cast(),
      slug: result["slug"].cast(),
      content: result["content"].cast(),
      excerpt: result["excerpt"].cast(),
      status: result["status"].cast(),
      published_at: result["published_at"].cast(),
      created_at: result["created_at"].cast(),
      updated_at: result["updated_at"].cast(),
    })
  }
}

///| GetPostBySlug
/// SELECT id, author_id, category_id, title, slug, content, excerpt, status, published_at, created_at, updated_at FROM posts WHERE slug = ?
pub async fn get_post_by_slug(db : @cloudflare.D1Database, params : GetPostBySlugParams) -> GetPostBySlugRow? {
  let stmt = db.prepare(get_post_by_slug_sql).bind([@core.any(params.slug)])
  match stmt.first() {
    None => None
    Some(result) => Some({
      id: result["id"].cast(),
      author_id: result["author_id"].cast(),
      category_id: result["category_id"].cast(),
      title: result["title"].cast(),
      slug: result["slug"].cast(),
      content: result["content"].cast(),
      excerpt: result["excerpt"].cast(),
      status: result["status"].cast(),
      published_at: result["published_at"].cast(),
      created_at: result["created_at"].cast(),
      updated_at: result["updated_at"].cast(),
    })
  }
}

///| ListPublishedPosts
/// SELECT id, author_id, category_id, title, slug, content, excerpt, status, published_at, created_at, updated_at FROM posts WHERE status = 'published' ORDER BY published_at DESC LIMIT ?
pub async fn list_published_posts(db : @cloudflare.D1Database, params : ListPublishedPostsParams) -> Array[ListPublishedPostsRow] {
  let stmt = db.prepare(list_published_posts_sql).bind([@core.any(params.limit.to_int())])
  let d1_result = stmt.all()
  let results_arr = d1_result.get_results()
  let results : Array[ListPublishedPostsRow] = []
  for row in results_arr {
    results.push({
      id: row["id"].cast(),
      author_id: row["author_id"].cast(),
      category_id: row["category_id"].cast(),
      title: row["title"].cast(),
      slug: row["slug"].cast(),
      content: row["content"].cast(),
      excerpt: row["excerpt"].cast(),
      status: row["status"].cast(),
      published_at: row["published_at"].cast(),
      created_at: row["created_at"].cast(),
      updated_at: row["updated_at"].cast(),
    })
  }
  results
}

///| ListPostsByAuthor
/// SELECT id, author_id, category_id, title, slug, content, excerpt, status, published_at, created_at, updated_at FROM posts WHERE author_id = ? ORDER BY created_at DESC
pub async fn list_posts_by_author(db : @cloudflare.D1Database, params : ListPostsByAuthorParams) -> Array[ListPostsByAuthorRow] {
  let stmt = db.prepare(list_posts_by_author_sql).bind([@core.any(params.author_id.to_int())])
  let d1_result = stmt.all()
  let results_arr = d1_result.get_results()
  let results : Array[ListPostsByAuthorRow] = []
  for row in results_arr {
    results.push({
      id: row["id"].cast(),
      author_id: row["author_id"].cast(),
      category_id: row["category_id"].cast(),
      title: row["title"].cast(),
      slug: row["slug"].cast(),
      content: row["content"].cast(),
      excerpt: row["excerpt"].cast(),
      status: row["status"].cast(),
      published_at: row["published_at"].cast(),
      created_at: row["created_at"].cast(),
      updated_at: row["updated_at"].cast(),
    })
  }
  results
}

///| CreatePost
/// INSERT INTO posts (author_id, category_id, title, slug, content, excerpt, status) VALUES (?, ?, ?, ?, ?, ?, ?)
pub async fn create_post(db : @cloudflare.D1Database, params : CreatePostParams) -> Unit {
  let stmt = db.prepare(create_post_sql).bind([@core.any(params.author_id.to_int()), (match params.category_id { Some(v) => @core.any(v.to_int()); None => @core.null() }), @core.any(params.title), @core.any(params.slug), @core.any(params.content), (match params.excerpt { Some(v) => @core.any(v); None => @core.null() }), @core.any(params.status)])
  stmt.run() |> ignore
}

///| PublishPost
/// UPDATE posts SET status = 'published', published_at = datetime('now'), updated_at = datetime('now') WHERE id = ?
pub async fn publish_post(db : @cloudflare.D1Database, params : PublishPostParams) -> Unit {
  let stmt = db.prepare(publish_post_sql).bind([@core.any(params.id.to_int())])
  stmt.run() |> ignore
}

///| DeletePost
/// DELETE FROM posts WHERE id = ?
pub async fn delete_post(db : @cloudflare.D1Database, params : DeletePostParams) -> Unit {
  let stmt = db.prepare(delete_post_sql).bind([@core.any(params.id.to_int())])
  stmt.run() |> ignore
}

///| ListTags
///  SELECT id, name, slug FROM tags ORDER BY name
pub async fn list_tags(db : @cloudflare.D1Database) -> Array[ListTagsRow] {
  let stmt = db.prepare(list_tags_sql)
  let d1_result = stmt.all()
  let results_arr = d1_result.get_results()
  let results : Array[ListTagsRow] = []
  for row in results_arr {
    results.push({
      id: row["id"].cast(),
      name: row["name"].cast(),
      slug: row["slug"].cast(),
    })
  }
  results
}

///| CreateTag
/// INSERT INTO tags (name, slug) VALUES (?, ?)
pub async fn create_tag(db : @cloudflare.D1Database, params : CreateTagParams) -> Unit {
  let stmt = db.prepare(create_tag_sql).bind([@core.any(params.name), @core.any(params.slug)])
  stmt.run() |> ignore
}

///| ListCommentsForPost
///  SELECT id, post_id, author_name, author_email, content, is_approved, created_at FROM comments WHERE post_id = ? AND is_approved = 1 ORDER BY created_at ASC
pub async fn list_comments_for_post(db : @cloudflare.D1Database, params : ListCommentsForPostParams) -> Array[ListCommentsForPostRow] {
  let stmt = db.prepare(list_comments_for_post_sql).bind([@core.any(params.post_id.to_int())])
  let d1_result = stmt.all()
  let results_arr = d1_result.get_results()
  let results : Array[ListCommentsForPostRow] = []
  for row in results_arr {
    results.push({
      id: row["id"].cast(),
      post_id: row["post_id"].cast(),
      author_name: row["author_name"].cast(),
      author_email: row["author_email"].cast(),
      content: row["content"].cast(),
      is_approved: row["is_approved"].cast(),
      created_at: row["created_at"].cast(),
    })
  }
  results
}

///| CreateComment
/// INSERT INTO comments (post_id, author_name, author_email, content) VALUES (?, ?, ?, ?)
pub async fn create_comment(db : @cloudflare.D1Database, params : CreateCommentParams) -> Unit {
  let stmt = db.prepare(create_comment_sql).bind([@core.any(params.post_id.to_int()), @core.any(params.author_name), @core.any(params.author_email), @core.any(params.content)])
  stmt.run() |> ignore
}

