// D1 Database Integration Tests
// Tests the SQL queries generated by sqlc-gen-moonbit

import { env } from "cloudflare:test";
import { describe, it, expect } from "vitest";
import * as queries from "../worker/queries";

// Migrations are applied by test/apply-migrations.ts setup file

describe("D1 Blog Queries", () => {
  describe("Users", () => {
    it("should create and retrieve a user", async () => {
      // Create user
      const result = await queries.createUser(
        env.DB,
        "alice",
        "alice@example.com",
        "Alice Developer",
        "MoonBit enthusiast",
        "https://example.com/alice.png"
      );
      expect(result.success).toBe(true);

      // Get user by username
      const user = await queries.getUserByUsername(env.DB, "alice");
      expect(user).not.toBeNull();
      expect(user?.username).toBe("alice");
      expect(user?.email).toBe("alice@example.com");
      expect(user?.display_name).toBe("Alice Developer");
      expect(user?.bio).toBe("MoonBit enthusiast");

      // Get user by id
      const userById = await queries.getUserById(env.DB, user!.id);
      expect(userById).not.toBeNull();
      expect(userById?.username).toBe("alice");
    });

    it("should list all users", async () => {
      // Create users for this test
      await queries.createUser(env.DB, "bob", "bob@example.com", "Bob Builder", null, null);
      await queries.createUser(env.DB, "charlie", "charlie@example.com", "Charlie Coder", null, null);

      const users = await queries.listUsers(env.DB);
      expect(users.length).toBeGreaterThanOrEqual(2);
      expect(users.map((u) => u.username)).toContain("bob");
      expect(users.map((u) => u.username)).toContain("charlie");
    });
  });

  describe("Categories", () => {
    it("should create and retrieve a category", async () => {
      const result = await queries.createCategory(env.DB, "Technology", "tech", "Tech articles");
      expect(result.success).toBe(true);

      const categories = await queries.listCategories(env.DB);
      expect(categories.length).toBeGreaterThanOrEqual(1);

      const techCategory = categories.find((c) => c.slug === "tech");
      expect(techCategory).not.toBeUndefined();
      expect(techCategory?.name).toBe("Technology");
      expect(techCategory?.description).toBe("Tech articles");
    });
  });

  describe("Tags", () => {
    it("should create and list tags", async () => {
      await queries.createTag(env.DB, "MoonBit", "moonbit");
      await queries.createTag(env.DB, "WebAssembly", "wasm");

      const tags = await queries.listTags(env.DB);
      expect(tags.length).toBeGreaterThanOrEqual(2);
      expect(tags.map((t) => t.slug)).toContain("moonbit");
      expect(tags.map((t) => t.slug)).toContain("wasm");
    });
  });

  describe("Posts", () => {
    it("should create, get, publish, and delete a post", async () => {
      // Create author first
      await queries.createUser(env.DB, "author1", "author1@example.com", "Test Author", null, null);
      const author = await queries.getUserByUsername(env.DB, "author1");
      expect(author).not.toBeNull();
      const authorId = author!.id;

      // Create a draft post
      const createResult = await queries.createPost(
        env.DB,
        authorId,
        null,
        "Getting Started with MoonBit",
        "getting-started-moonbit",
        "MoonBit is a new programming language...",
        "Learn MoonBit basics",
        "draft"
      );
      expect(createResult.success).toBe(true);

      // Get post by slug
      const post = await queries.getPostBySlug(env.DB, "getting-started-moonbit");
      expect(post).not.toBeNull();
      expect(post?.title).toBe("Getting Started with MoonBit");
      expect(post?.status).toBe("draft");

      // Draft posts should not appear in published list
      const publishedPosts = await queries.listPublishedPosts(env.DB, 10);
      const draftPost = publishedPosts.find((p) => p.slug === "getting-started-moonbit");
      expect(draftPost).toBeUndefined();

      // Publish the post
      await queries.publishPost(env.DB, post!.id);

      const publishedPost = await queries.getPostBySlug(env.DB, "getting-started-moonbit");
      expect(publishedPost?.status).toBe("published");
      expect(publishedPost?.published_at).not.toBeNull();

      // Should appear in published list now
      const publishedPostsAfter = await queries.listPublishedPosts(env.DB, 10);
      const found = publishedPostsAfter.find((p) => p.slug === "getting-started-moonbit");
      expect(found).not.toBeUndefined();

      // List posts by author
      const authorPosts = await queries.listPostsByAuthor(env.DB, authorId);
      expect(authorPosts.length).toBeGreaterThanOrEqual(1);
      expect(authorPosts.every((p) => p.author_id === authorId)).toBe(true);
    });

    it("should delete a post", async () => {
      // Create author
      await queries.createUser(env.DB, "author2", "author2@example.com", "Delete Test Author", null, null);
      const author = await queries.getUserByUsername(env.DB, "author2");
      const authorId = author!.id;

      // Create a post to delete
      await queries.createPost(
        env.DB,
        authorId,
        null,
        "To Be Deleted",
        "to-be-deleted",
        "This post will be deleted",
        null,
        "draft"
      );

      const post = await queries.getPostBySlug(env.DB, "to-be-deleted");
      expect(post).not.toBeNull();

      await queries.deletePost(env.DB, post!.id);

      const deletedPost = await queries.getPostBySlug(env.DB, "to-be-deleted");
      expect(deletedPost).toBeNull();
    });
  });

  describe("Comments", () => {
    it("should create comments and list approved ones", async () => {
      // Create author and post
      await queries.createUser(env.DB, "author3", "author3@example.com", "Comment Test Author", null, null);
      const author = await queries.getUserByUsername(env.DB, "author3");
      const authorId = author!.id;

      await queries.createPost(
        env.DB,
        authorId,
        null,
        "Post for Comments",
        "post-for-comments",
        "This post will have comments",
        null,
        "published"
      );
      const post = await queries.getPostBySlug(env.DB, "post-for-comments");
      expect(post).not.toBeNull();
      const postId = post!.id;

      // Create a comment
      const result = await queries.createComment(env.DB, postId, "John Doe", "john@example.com", "Great article!");
      expect(result.success).toBe(true);

      // New comments are not approved by default
      const comments = await queries.listCommentsForPost(env.DB, postId);
      // Should be empty because comments are not approved by default
      expect(comments.length).toBe(0);

      // Manually approve comment
      await env.DB.prepare("UPDATE comments SET is_approved = 1 WHERE post_id = ?").bind(postId).run();

      const commentsAfter = await queries.listCommentsForPost(env.DB, postId);
      expect(commentsAfter.length).toBeGreaterThanOrEqual(1);
      expect(commentsAfter[0].author_name).toBe("John Doe");
      expect(commentsAfter[0].content).toBe("Great article!");
    });
  });
});
