// Generated by sqlc-gen-moonbit (backend: mysql_js)
// Requires: npm install mysql2

// MySQL2 Pool FFI bindings
#external
pub type MysqlPool

#external
pub type MysqlResult

///| Create MySQL connection pool
extern "js" fn ffi_mysql_create_pool(config : @core.Any) -> MysqlPool =
  #| (config) => require("mysql2/promise").createPool(config)

///| Create MySQL pool with labeled arguments
pub fn MysqlPool::new(
  host? : String,
  port? : Int,
  user? : String,
  password? : String,
  database? : String,
) -> MysqlPool {
  let config = @core.new_object()
  if host is Some(v) { config["host"] = @core.any(v) }
  if port is Some(v) { config["port"] = @core.any(v) }
  if user is Some(v) { config["user"] = @core.any(v) }
  if password is Some(v) { config["password"] = @core.any(v) }
  if database is Some(v) { config["database"] = @core.any(v) }
  ffi_mysql_create_pool(config)
}

///| Execute query with parameters
extern "js" fn ffi_mysql_execute(
  pool : MysqlPool,
  sql : String,
  params : Array[@core.Any],
) -> @core.Promise[MysqlResult] =
  #| async (pool, sql, params) => { const [rows, fields] = await pool.execute(sql, params); return { rows, fields, insertId: rows.insertId, affectedRows: rows.affectedRows }; }

///| Execute query without parameters
extern "js" fn ffi_mysql_execute_no_params(
  pool : MysqlPool,
  sql : String,
) -> @core.Promise[MysqlResult] =
  #| async (pool, sql) => { const [rows, fields] = await pool.execute(sql); return { rows, fields, insertId: rows.insertId, affectedRows: rows.affectedRows }; }

///| Execute query
pub async fn MysqlPool::execute(
  self : MysqlPool,
  sql : String,
  params? : Array[@core.Any] = [],
) -> MysqlResult {
  if params.length() == 0 {
    ffi_mysql_execute_no_params(self, sql).wait()
  } else {
    ffi_mysql_execute(self, sql, params).wait()
  }
}

///| Close pool
extern "js" fn ffi_mysql_pool_end(pool : MysqlPool) -> @core.Promise[Unit] =
  #| (pool) => pool.end()

///| Close pool
pub async fn MysqlPool::end(self : MysqlPool) -> Unit {
  ffi_mysql_pool_end(self).wait()
}

///| Get rows from result
extern "js" fn ffi_mysql_result_rows(result : MysqlResult) -> @core.Any =
  #| (result) => result.rows

///| Get rows
pub fn MysqlResult::rows(self : MysqlResult) -> @core.Any {
  ffi_mysql_result_rows(self)
}

///| Get insert ID
extern "js" fn ffi_mysql_result_insert_id(result : MysqlResult) -> @core.Any =
  #| (result) => result.insertId

///| Get insert ID
pub fn MysqlResult::insertId(self : MysqlResult) -> @core.Any {
  ffi_mysql_result_insert_id(self)
}

///| Get affected rows
extern "js" fn ffi_mysql_result_affected_rows(result : MysqlResult) -> Int =
  #| (result) => result.affectedRows ?? 0

///| Get affected rows
pub fn MysqlResult::affectedRows(self : MysqlResult) -> Int {
  ffi_mysql_result_affected_rows(self)
}

///| Convert JavaScript number to Int64
extern "js" fn js_number_to_int64(v : @core.Any) -> Int64 =
  #| (v) => { const n = Number(v); return { hi: Math.floor(n / 0x100000000), lo: n >>> 0 }; }

///| Convert Int64 to JavaScript number
extern "js" fn int64_to_js_number(v : Int64) -> @core.Any =
  #| (v) => v.hi * 0x100000000 + (v.lo >>> 0)

// Query functions
///| GetUser
/// SELECT id, name, email, created_at FROM users WHERE id = ?
pub async fn get_user(pool : MysqlPool, params : GetUserParams) -> GetUserRow? {
  let result = pool.execute(get_user_sql, params=[int64_to_js_number(params.id)])
  let rows = result.rows()
  let len : Int = rows["length"].cast()
  if len == 0 {
    None
  } else {
    let row = rows._get_by_index(0)
    Some({
      id: js_number_to_int64(row["id"]),
      name: row["name"].cast(),
      email: row["email"].cast(),
      created_at: (if @core.is_null(row["created_at"]) || @core.typeof_(row["created_at"]) == "undefined" { None } else { Some(row["created_at"].cast()) }),
    })
  }
}

///| ListUsers
/// SELECT id, name, email, created_at FROM users ORDER BY id
pub async fn list_users(pool : MysqlPool) -> Array[ListUsersRow] {
  let result = pool.execute(list_users_sql)
  let rows = result.rows()
  let len : Int = rows["length"].cast()
  let results : Array[ListUsersRow] = []
  for i = 0; i < len; i = i + 1 {
    let row = rows._get_by_index(i)
    results.push({
      id: js_number_to_int64(row["id"]),
      name: row["name"].cast(),
      email: row["email"].cast(),
      created_at: (if @core.is_null(row["created_at"]) || @core.typeof_(row["created_at"]) == "undefined" { None } else { Some(row["created_at"].cast()) }),
    })
  }
  results
}

///| CreateUser
/// INSERT INTO users (name, email) VALUES (?, ?)
pub async fn create_user(pool : MysqlPool, params : CreateUserParams) -> Int64 {
  let result = pool.execute(create_user_sql, params=[@core.any(params.name), @core.any(params.email)])
  js_number_to_int64(result.insertId())
}

///| UpdateUser
/// UPDATE users SET name = ?, email = ? WHERE id = ?
pub async fn update_user(pool : MysqlPool, params : UpdateUserParams) -> Int {
  let result = pool.execute(update_user_sql, params=[@core.any(params.name), @core.any(params.email), int64_to_js_number(params.id)])
  result.affectedRows()
}

///| DeleteUser
/// DELETE FROM users WHERE id = ?
pub async fn delete_user(pool : MysqlPool, params : DeleteUserParams) -> Unit {
  let result = pool.execute(delete_user_sql, params=[int64_to_js_number(params.id)])
  ignore(result)
}

