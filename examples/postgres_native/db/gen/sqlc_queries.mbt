// Generated by sqlc-gen-moonbit (backend: postgres)
// Requires: mattn/postgres

///| Escape single quotes for SQL
fn sql_escape(s : String) -> String {
  s.replace(old="'", new="''")
}

// Query functions
///| GetUser
/// SELECT id, name, email, created_at FROM users WHERE id = $1
pub fn get_user(conn : @postgres.Connection, params : GetUserParams) -> Result[GetUserRow?, @postgres.PgError] {
  let sql = get_user_sql
  let sql = sql.replace(old="$1", new=params.id.to_string())
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      if rows.length() == 0 {
        Ok(None)
      } else {
        let row = rows[0]
        Ok(Some({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          name: row[1],
          email: row[2],
          created_at: (if row[3].length() == 0 { None } else { Some(row[3]) }),
        }))
      }
    }
  }
}

///| ListUsers
/// SELECT id, name, email, created_at FROM users ORDER BY id
pub fn list_users(conn : @postgres.Connection) -> Result[Array[ListUsersRow], @postgres.PgError] {
  let result = conn.query(list_users_sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      let results : Array[ListUsersRow] = []
      for row in rows {
        results.push({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          name: row[1],
          email: row[2],
          created_at: (if row[3].length() == 0 { None } else { Some(row[3]) }),
        })
      }
      Ok(results)
    }
  }
}

///| CreateUser
/// INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id
pub fn create_user(conn : @postgres.Connection, params : CreateUserParams) -> Result[Int64, @postgres.PgError] {
  let sql = create_user_sql
  let sql = sql.replace(old="$1", new="'" + sql_escape(params.name.to_string()) + "'")
  let sql = sql.replace(old="$2", new="'" + sql_escape(params.email.to_string()) + "'")
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      // For INSERT RETURNING, get the returned id from first row
      let rows = qr.rows()
      qr.free()
      if rows.length() > 0 && rows[0].length() > 0 {
        Ok(try { @strconv.parse_int64(rows[0][0]) } catch { _ => 0L })
      } else {
        Ok(0L)
      }
    }
  }
}

///| UpdateUser
/// UPDATE users SET name = $2, email = $3 WHERE id = $1
pub fn update_user(conn : @postgres.Connection, params : UpdateUserParams) -> Result[Int, @postgres.PgError] {
  let sql = update_user_sql
  let sql = sql.replace(old="$1", new=params.id.to_string())
  let sql = sql.replace(old="$2", new="'" + sql_escape(params.name.to_string()) + "'")
  let sql = sql.replace(old="$3", new="'" + sql_escape(params.email.to_string()) + "'")
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let count = qr.affected_rows()
      qr.free()
      Ok(count)
    }
  }
}

///| DeleteUser
/// DELETE FROM users WHERE id = $1
pub fn delete_user(conn : @postgres.Connection, params : DeleteUserParams) -> Result[Unit, @postgres.PgError] {
  let sql = delete_user_sql
  let sql = sql.replace(old="$1", new=params.id.to_string())
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      qr.free()
      Ok(())
    }
  }
}
