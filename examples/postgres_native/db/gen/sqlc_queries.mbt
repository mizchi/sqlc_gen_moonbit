// Generated by sqlc-gen-moonbit (backend: postgres)
// Requires: mattn/postgres

// Query functions
///| GetUser
/// SELECT id, name, email, created_at FROM users WHERE id = $1
pub fn get_user(conn : @postgres.Connection, params : GetUserParams) -> Result[GetUserRow?, @postgres.PgError] {
  let params : Array[@postgres.Value] = [
    @postgres.ToValue::to_value(params.id)
  ]
  let result = conn.execute(get_user_sql, params)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      if rows.length() == 0 {
        Ok(None)
      } else {
        let row = rows[0]
        Ok(Some({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          name: row[1],
          email: row[2],
          created_at: (if row[3].length() == 0 { None } else { Some(row[3]) }),
        }))
      }
    }
  }
}

///| ListUsers
/// SELECT id, name, email, created_at FROM users ORDER BY id
pub fn list_users(conn : @postgres.Connection) -> Result[Array[ListUsersRow], @postgres.PgError] {
  let result = conn.query(list_users_sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      let results : Array[ListUsersRow] = []
      for row in rows {
        results.push({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          name: row[1],
          email: row[2],
          created_at: (if row[3].length() == 0 { None } else { Some(row[3]) }),
        })
      }
      Ok(results)
    }
  }
}

///| CreateUser
/// INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id
pub fn create_user(conn : @postgres.Connection, params : CreateUserParams) -> Result[Int64, @postgres.PgError] {
  let params : Array[@postgres.Value] = [
    @postgres.ToValue::to_value(params.name),
    @postgres.ToValue::to_value(params.email)
  ]
  let result = conn.execute(create_user_sql, params)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      // For INSERT RETURNING, get the returned id from first row
      let rows = qr.rows()
      qr.free()
      if rows.length() > 0 && rows[0].length() > 0 {
        Ok(try { @strconv.parse_int64(rows[0][0]) } catch { _ => 0L })
      } else {
        Ok(0L)
      }
    }
  }
}

///| UpdateUser
/// UPDATE users SET name = $2, email = $3 WHERE id = $1
pub fn update_user(conn : @postgres.Connection, params : UpdateUserParams) -> Result[Int, @postgres.PgError] {
  let params : Array[@postgres.Value] = [
    @postgres.ToValue::to_value(params.id),
    @postgres.ToValue::to_value(params.name),
    @postgres.ToValue::to_value(params.email)
  ]
  let result = conn.execute(update_user_sql, params)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let count = qr.affected_rows()
      qr.free()
      Ok(count)
    }
  }
}

///| DeleteUser
/// DELETE FROM users WHERE id = $1
pub fn delete_user(conn : @postgres.Connection, params : DeleteUserParams) -> Result[Unit, @postgres.PgError] {
  let params : Array[@postgres.Value] = [
    @postgres.ToValue::to_value(params.id)
  ]
  let result = conn.execute(delete_user_sql, params)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      qr.free()
      Ok(())
    }
  }
}

