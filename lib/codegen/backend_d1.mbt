// D1 backend (Cloudflare Workers, js target)

///|
pub fn generate_queries_d1(
  request : @plugin.GenerateRequest,
  overrides : Array[TypeOverride],
) -> String {
  let buf = StringBuilder::new()
  buf.write_string("// Generated by sqlc-gen-moonbit (backend: d1)\n")
  buf.write_string("// Requires: mizchi/cloudflare\n\n")

  // Generate query functions using cloudflare.mbt D1 types
  buf.write_string("// Query functions\n")
  for query in request.queries {
    generate_query_function_d1(buf, query, overrides)
  }
  buf.to_string()
}

///|
fn generate_query_function_d1(
  buf : StringBuilder,
  query : @plugin.Query,
  _overrides : Array[TypeOverride],
) -> Unit {
  let func_name = to_snake_case(query.name)
  let sql_const = to_snake_case(query.name) + "_sql"
  let row_type = to_pascal_case(query.name) + "Row"
  let param_count = query.params.length()

  // Return type with async
  let return_type = match query.cmd {
    ":one" => row_type + "?"
    ":many" => "Array[" + row_type + "]"
    ":execrows" => "Int"
    ":execlastid" => "Int64"
    _ => "Unit"
  }

  // Doc comment
  buf.write_string("///| ")
  buf.write_string(query.name)
  buf.write_string("\n")
  buf.write_string("/// ")
  buf.write_string(sanitize_newlines(query.text))
  buf.write_string("\n")

  // Function signature - async with D1Database type from cloudflare.mbt
  // Uses @cloudflare.D1Error directly (no SqlError wrapper)
  buf.write_string("pub async fn ")
  buf.write_string(func_name)
  buf.write_string("(db : @cloudflare.D1Database")
  if param_count > 0 {
    buf.write_string(", params : ")
    buf.write_string(to_pascal_case(query.name))
    buf.write_string("Params")
  }
  buf.write_string(") -> ")
  buf.write_string(return_type)
  buf.write_string(" raise @cloudflare.D1Error {\n")

  // Prepare and bind statement using cloudflare.mbt API
  // Errors from cloudflare.mbt D1 methods propagate directly
  buf.write_string("  let stmt = db.prepare(")
  buf.write_string(sql_const)
  buf.write_string(")")
  if param_count > 0 {
    buf.write_string(".bind([")
    for i, param in query.params {
      let col = param.column
      let param_name = if col.name.length() > 0 {
        to_snake_case(col.name)
      } else {
        "p" + param.number.to_string()
      }
      if i > 0 {
        buf.write_string(", ")
      }
      buf.write_string(d1_param_to_core_any(col, "params." + param_name))
    }
    buf.write_string("])")
  }
  buf.write_string("\n")

  // Execute based on command type
  match query.cmd {
    ":one" => {
      buf.write_string("  match stmt.first() {\n")
      buf.write_string("    None => None\n")
      buf.write_string("    Some(result) => Some({\n")
      for col in query.columns {
        buf.write_string("      ")
        buf.write_string(to_snake_case(col.name))
        buf.write_string(": ")
        buf.write_string(d1_column_from_core_any(col, "result"))
        buf.write_string(",\n")
      }
      buf.write_string("    })\n")
      buf.write_string("  }\n")
    }
    ":many" => {
      buf.write_string("  let d1_result = stmt.all()\n")
      buf.write_string("  let results_arr = d1_result.get_results()\n")
      buf.write_string("  let results : Array[")
      buf.write_string(row_type)
      buf.write_string("] = []\n")
      buf.write_string("  for row in results_arr {\n")
      buf.write_string("    results.push({\n")
      for col in query.columns {
        buf.write_string("      ")
        buf.write_string(to_snake_case(col.name))
        buf.write_string(": ")
        buf.write_string(d1_column_from_core_any(col, "row"))
        buf.write_string(",\n")
      }
      buf.write_string("    })\n")
      buf.write_string("  }\n")
      buf.write_string("  results\n")
    }
    ":execrows" => {
      buf.write_string("  let result = stmt.run()\n")
      buf.write_string("  match result.meta() {\n")
      buf.write_string("    Some(m) => m.changes().unwrap_or(0)\n")
      buf.write_string("    None => 0\n")
      buf.write_string("  }\n")
    }
    ":execlastid" => {
      buf.write_string("  let result = stmt.run()\n")
      buf.write_string("  match result.meta() {\n")
      buf.write_string(
        "    Some(m) => m.last_row_id().unwrap_or(0).to_int64()\n",
      )
      buf.write_string("    None => 0L\n")
      buf.write_string("  }\n")
    }
    _ =>
      // :exec
      buf.write_string("  stmt.run() |> ignore\n")
  }
  buf.write_string("}\n\n")
}

///|
fn d1_param_to_core_any(col : @plugin.Column, expr : String) -> String {
  let type_name = col.type_.name.to_upper()
  // For nullable types, we need to handle Option
  let is_nullable = not(col.not_null)
  if is_nullable {
    // For nullable params, use match to handle None - @core.null() for null value
    "(match " + expr + " { Some(v) => @core.any(v); None => @core.null() })"
  } else {
    match type_name {
      "INTEGER" | "INT" | "INT4" | "SMALLINT" | "INT8" | "BIGINT" =>
        "@core.any(" + expr + ")"
      "REAL" | "FLOAT" | "DOUBLE" | "NUMERIC" | "DECIMAL" =>
        "@core.any(" + expr + ")"
      "TEXT" | "VARCHAR" | "CHAR" | "CHARACTER" | "CLOB" =>
        "@core.any(" + expr + ")"
      "BOOLEAN" | "BOOL" => "@core.any(" + expr + ")"
      _ => "@core.any(" + expr + ".to_string())"
    }
  }
}

///|
fn d1_column_from_core_any(col : @plugin.Column, obj_expr : String) -> String {
  let type_name = col.type_.name.to_upper()
  let field_name = "\"" + col.name + "\""
  let field_access = obj_expr + "[" + field_name + "]"

  // Handle nullable columns
  if not(col.not_null) {
    // For nullable columns, check for null/undefined first
    match type_name {
      "INTEGER" | "INT" | "INT4" =>
        "(if @core.is_null(" +
        field_access +
        ") || @core.typeof_(" +
        field_access +
        ") == \"undefined\" { None } else { Some(@cloudflare.js_number_to_int64(" +
        field_access +
        ")) })"
      "SMALLINT" =>
        "(if @core.is_null(" +
        field_access +
        ") || @core.typeof_(" +
        field_access +
        ") == \"undefined\" { None } else { Some(@cloudflare.js_number_to_int64(" +
        field_access +
        ").to_int()) })"
      "INT8" | "BIGINT" =>
        "(if @core.is_null(" +
        field_access +
        ") || @core.typeof_(" +
        field_access +
        ") == \"undefined\" { None } else { Some(@cloudflare.js_number_to_int64(" +
        field_access +
        ")) })"
      _ =>
        "(if @core.is_null(" +
        field_access +
        ") || @core.typeof_(" +
        field_access +
        ") == \"undefined\" { None } else { Some(" +
        field_access +
        ".cast()) })"
    }
  } else {
    // Non-nullable columns
    match type_name {
      // Use @cloudflare.js_number_to_int64 for INTEGER types
      // D1/SQLite returns JavaScript numbers which need conversion to MoonBit Int64 ({hi, lo} format)
      // For smaller integer types (INTEGER, INT, INT4, SMALLINT), convert to Int
      "INTEGER" | "INT" | "INT4" =>
        "@cloudflare.js_number_to_int64(" + field_access + ")"
      "SMALLINT" =>
        "@cloudflare.js_number_to_int64(" + field_access + ").to_int()"
      "INT8" | "BIGINT" =>
        "@cloudflare.js_number_to_int64(" + field_access + ")"
      "REAL" | "FLOAT" | "DOUBLE" | "NUMERIC" | "DECIMAL" =>
        field_access + ".cast()"
      "TEXT" | "VARCHAR" | "CHAR" | "CHARACTER" | "CLOB" =>
        field_access + ".cast()"
      "BOOLEAN" | "BOOL" => field_access + ".cast()"
      _ => field_access + ".cast()"
    }
  }
}
