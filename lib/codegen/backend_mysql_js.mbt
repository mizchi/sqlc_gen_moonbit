// MySQL JS backend (js target, using mysql2/promise)

///|
pub fn generate_queries_mysql_js(
  request : @plugin.GenerateRequest,
  overrides : Array[TypeOverride],
) -> String {
  let buf = StringBuilder::new()
  buf.write_string("// Generated by sqlc-gen-moonbit (backend: mysql_js)\n")
  buf.write_string("// Requires: npm install mysql2\n\n")

  // Generate MySQL Pool type and FFI bindings
  buf.write_string("// MySQL2 Pool FFI bindings\n")
  buf.write_string("#external\n")
  buf.write_string("pub type MysqlPool\n\n")
  buf.write_string("#external\n")
  buf.write_string("pub type MysqlResult\n\n")

  // Pool::new with connection config
  buf.write_string("///| Create MySQL connection pool\n")
  buf.write_string("extern \"js\" fn ffi_mysql_create_pool(config : @core.Any) -> MysqlPool =\n")
  buf.write_string("  #| (config) => require(\"mysql2/promise\").createPool(config)\n\n")

  buf.write_string("///| Create MySQL pool with labeled arguments\n")
  buf.write_string("pub fn MysqlPool::new(\n")
  buf.write_string("  host? : String,\n")
  buf.write_string("  port? : Int,\n")
  buf.write_string("  user? : String,\n")
  buf.write_string("  password? : String,\n")
  buf.write_string("  database? : String,\n")
  buf.write_string(") -> MysqlPool {\n")
  buf.write_string("  let config = @core.new_object()\n")
  buf.write_string("  if host is Some(v) { config[\"host\"] = @core.any(v) }\n")
  buf.write_string("  if port is Some(v) { config[\"port\"] = @core.any(v) }\n")
  buf.write_string("  if user is Some(v) { config[\"user\"] = @core.any(v) }\n")
  buf.write_string("  if password is Some(v) { config[\"password\"] = @core.any(v) }\n")
  buf.write_string("  if database is Some(v) { config[\"database\"] = @core.any(v) }\n")
  buf.write_string("  ffi_mysql_create_pool(config)\n")
  buf.write_string("}\n\n")

  // Pool::execute
  buf.write_string("///| Execute query with parameters\n")
  buf.write_string("extern \"js\" fn ffi_mysql_execute(\n")
  buf.write_string("  pool : MysqlPool,\n")
  buf.write_string("  sql : String,\n")
  buf.write_string("  params : Array[@core.Any],\n")
  buf.write_string(") -> @core.Promise[MysqlResult] =\n")
  buf.write_string("  #| async (pool, sql, params) => { const [rows, fields] = await pool.execute(sql, params); return { rows, fields, insertId: rows.insertId, affectedRows: rows.affectedRows }; }\n\n")

  buf.write_string("///| Execute query without parameters\n")
  buf.write_string("extern \"js\" fn ffi_mysql_execute_no_params(\n")
  buf.write_string("  pool : MysqlPool,\n")
  buf.write_string("  sql : String,\n")
  buf.write_string(") -> @core.Promise[MysqlResult] =\n")
  buf.write_string("  #| async (pool, sql) => { const [rows, fields] = await pool.execute(sql); return { rows, fields, insertId: rows.insertId, affectedRows: rows.affectedRows }; }\n\n")

  buf.write_string("///| Execute query\n")
  buf.write_string("pub async fn MysqlPool::execute(\n")
  buf.write_string("  self : MysqlPool,\n")
  buf.write_string("  sql : String,\n")
  buf.write_string("  params? : Array[@core.Any] = [],\n")
  buf.write_string(") -> MysqlResult {\n")
  buf.write_string("  if params.length() == 0 {\n")
  buf.write_string("    ffi_mysql_execute_no_params(self, sql).wait()\n")
  buf.write_string("  } else {\n")
  buf.write_string("    ffi_mysql_execute(self, sql, params).wait()\n")
  buf.write_string("  }\n")
  buf.write_string("}\n\n")

  // Pool::end
  buf.write_string("///| Close pool\n")
  buf.write_string("extern \"js\" fn ffi_mysql_pool_end(pool : MysqlPool) -> @core.Promise[Unit] =\n")
  buf.write_string("  #| (pool) => pool.end()\n\n")

  buf.write_string("///| Close pool\n")
  buf.write_string("pub async fn MysqlPool::end(self : MysqlPool) -> Unit {\n")
  buf.write_string("  ffi_mysql_pool_end(self).wait()\n")
  buf.write_string("}\n\n")

  // Result accessors
  buf.write_string("///| Get rows from result\n")
  buf.write_string("extern \"js\" fn ffi_mysql_result_rows(result : MysqlResult) -> @core.Any =\n")
  buf.write_string("  #| (result) => result.rows\n\n")

  buf.write_string("///| Get rows\n")
  buf.write_string("pub fn MysqlResult::rows(self : MysqlResult) -> @core.Any {\n")
  buf.write_string("  ffi_mysql_result_rows(self)\n")
  buf.write_string("}\n\n")

  buf.write_string("///| Get insert ID\n")
  buf.write_string("extern \"js\" fn ffi_mysql_result_insert_id(result : MysqlResult) -> @core.Any =\n")
  buf.write_string("  #| (result) => result.insertId\n\n")

  buf.write_string("///| Get insert ID\n")
  buf.write_string("pub fn MysqlResult::insertId(self : MysqlResult) -> @core.Any {\n")
  buf.write_string("  ffi_mysql_result_insert_id(self)\n")
  buf.write_string("}\n\n")

  buf.write_string("///| Get affected rows\n")
  buf.write_string("extern \"js\" fn ffi_mysql_result_affected_rows(result : MysqlResult) -> Int =\n")
  buf.write_string("  #| (result) => result.affectedRows ?? 0\n\n")

  buf.write_string("///| Get affected rows\n")
  buf.write_string("pub fn MysqlResult::affectedRows(self : MysqlResult) -> Int {\n")
  buf.write_string("  ffi_mysql_result_affected_rows(self)\n")
  buf.write_string("}\n\n")

  // Generate helper functions for Int64 conversion
  buf.write_string("///| Convert JavaScript number to Int64\n")
  buf.write_string("extern \"js\" fn js_number_to_int64(v : @core.Any) -> Int64 =\n")
  buf.write_string("  #| (v) => { const n = Number(v); return { hi: Math.floor(n / 0x100000000), lo: n >>> 0 }; }\n\n")
  buf.write_string("///| Convert Int64 to JavaScript number\n")
  buf.write_string("extern \"js\" fn int64_to_js_number(v : Int64) -> @core.Any =\n")
  buf.write_string("  #| (v) => v.hi * 0x100000000 + (v.lo >>> 0)\n\n")

  // Generate query functions
  buf.write_string("// Query functions\n")
  for query in request.queries {
    generate_query_function_mysql_js(buf, query, overrides)
  }
  buf.to_string()
}

///|
fn generate_query_function_mysql_js(
  buf : StringBuilder,
  query : @plugin.Query,
  _overrides : Array[TypeOverride],
) -> Unit {
  let func_name = to_snake_case(query.name)
  let sql_const = to_snake_case(query.name) + "_sql"
  let row_type = to_pascal_case(query.name) + "Row"
  let param_count = query.params.length()

  // Return type with async
  let return_type = match query.cmd {
    ":one" => row_type + "?"
    ":many" => "Array[" + row_type + "]"
    ":execrows" => "Int"
    ":execlastid" => "Int64"
    _ => "Unit"
  }

  // Doc comment
  buf.write_string("///| ")
  buf.write_string(query.name)
  buf.write_string("\n")
  buf.write_string("/// ")
  buf.write_string(sanitize_newlines(query.text))
  buf.write_string("\n")

  // Function signature - async with MysqlPool
  buf.write_string("pub async fn ")
  buf.write_string(func_name)
  buf.write_string("(pool : MysqlPool")
  if param_count > 0 {
    buf.write_string(", params : ")
    buf.write_string(to_pascal_case(query.name))
    buf.write_string("Params")
  }
  buf.write_string(") -> ")
  buf.write_string(return_type)
  buf.write_string(" {\n")

  // Execute query with parameters
  buf.write_string("  let result = pool.execute(")
  buf.write_string(sql_const)
  if param_count > 0 {
    buf.write_string(", params=[")
    for i, param in query.params {
      let col = param.column
      let param_name = if col.name.length() > 0 {
        to_snake_case(col.name)
      } else {
        "p" + param.number.to_string()
      }
      if i > 0 {
        buf.write_string(", ")
      }
      buf.write_string(mysql_js_param_to_any(col, "params." + param_name))
    }
    buf.write_string("]")
  }
  buf.write_string(")\n")

  // Process result based on command type
  match query.cmd {
    ":one" => {
      buf.write_string("  let rows = result.rows()\n")
      buf.write_string("  let len : Int = rows[\"length\"].cast()\n")
      buf.write_string("  if len == 0 {\n")
      buf.write_string("    None\n")
      buf.write_string("  } else {\n")
      buf.write_string("    let row = rows._get_by_index(0)\n")
      buf.write_string("    Some({\n")
      for col in query.columns {
        buf.write_string("      ")
        buf.write_string(to_snake_case(col.name))
        buf.write_string(": ")
        buf.write_string(mysql_js_column_from_any(col, "row"))
        buf.write_string(",\n")
      }
      buf.write_string("    })\n")
      buf.write_string("  }\n")
    }
    ":many" => {
      buf.write_string("  let rows = result.rows()\n")
      buf.write_string("  let len : Int = rows[\"length\"].cast()\n")
      buf.write_string("  let results : Array[")
      buf.write_string(row_type)
      buf.write_string("] = []\n")
      buf.write_string("  for i = 0; i < len; i = i + 1 {\n")
      buf.write_string("    let row = rows._get_by_index(i)\n")
      buf.write_string("    results.push({\n")
      for col in query.columns {
        buf.write_string("      ")
        buf.write_string(to_snake_case(col.name))
        buf.write_string(": ")
        buf.write_string(mysql_js_column_from_any(col, "row"))
        buf.write_string(",\n")
      }
      buf.write_string("    })\n")
      buf.write_string("  }\n")
      buf.write_string("  results\n")
    }
    ":execrows" => {
      buf.write_string("  result.affectedRows()\n")
    }
    ":execlastid" => {
      // MySQL uses insertId from result, not RETURNING
      buf.write_string("  js_number_to_int64(result.insertId())\n")
    }
    _ => {
      // :exec
      buf.write_string("  ignore(result)\n")
    }
  }
  buf.write_string("}\n\n")
}

///|
fn mysql_js_param_to_any(col : @plugin.Column, expr : String) -> String {
  let type_name = col.type_.name.to_upper()
  let is_nullable = not(col.not_null)
  let is_int64 = type_name == "BIGINT"
  if is_nullable {
    // For nullable types, handle Option - convert None to @core.null()
    if is_int64 {
      "(match " +
      expr +
      " { Some(v) => int64_to_js_number(v); None => @core.null() })"
    } else {
      "(match " + expr + " { Some(v) => @core.any(v); None => @core.null() })"
    }
  } else {
    if is_int64 {
      "int64_to_js_number(" + expr + ")"
    } else {
      "@core.any(" + expr + ")"
    }
  }
}

///|
fn mysql_js_column_from_any(col : @plugin.Column, obj_expr : String) -> String {
  let type_name = col.type_.name.to_upper()
  let field_name = "\"" + col.name + "\""
  let field_access = obj_expr + "[" + field_name + "]"

  // Handle nullable columns
  if not(col.not_null) {
    // For nullable columns, check for null/undefined first
    match type_name {
      "INT" | "INTEGER" | "TINYINT" | "SMALLINT" | "MEDIUMINT" =>
        "(if @core.is_null(" +
        field_access +
        ") || @core.typeof_(" +
        field_access +
        ") == \"undefined\" { None } else { Some(" +
        field_access +
        ".cast()) })"
      "BIGINT" =>
        "(if @core.is_null(" +
        field_access +
        ") || @core.typeof_(" +
        field_access +
        ") == \"undefined\" { None } else { Some(js_number_to_int64(" +
        field_access +
        ")) })"
      _ =>
        "(if @core.is_null(" +
        field_access +
        ") || @core.typeof_(" +
        field_access +
        ") == \"undefined\" { None } else { Some(" +
        field_access +
        ".cast()) })"
    }
  } else {
    // Non-nullable columns
    match type_name {
      "INT" | "INTEGER" | "TINYINT" | "SMALLINT" | "MEDIUMINT" =>
        field_access + ".cast()"
      "BIGINT" =>
        "js_number_to_int64(" + field_access + ")"
      _ => field_access + ".cast()"
    }
  }
}
