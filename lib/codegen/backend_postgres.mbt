// PostgreSQL backend (native target)

///|
pub fn generate_queries_postgres(
  request : @plugin.GenerateRequest,
  overrides : Array[TypeOverride],
) -> String {
  let buf = StringBuilder::new()
  buf.write_string("// Generated by sqlc-gen-moonbit (backend: postgres)\n")
  buf.write_string("// Requires: mattn/postgres\n\n")

  // Generate query functions using mattn/postgres types
  buf.write_string("// Query functions\n")
  for query in request.queries {
    generate_query_function_postgres(buf, query, overrides)
  }
  buf.to_string()
}

///|
fn generate_query_function_postgres(
  buf : StringBuilder,
  query : @plugin.Query,
  _overrides : Array[TypeOverride],
) -> Unit {
  let func_name = to_snake_case(query.name)
  let sql_const = to_snake_case(query.name) + "_sql"
  let row_type = to_pascal_case(query.name) + "Row"

  // Return type (sync API with Result)
  let return_type = match query.cmd {
    ":one" => "Result[" + row_type + "?, @postgres.PgError]"
    ":many" => "Result[Array[" + row_type + "], @postgres.PgError]"
    ":execrows" => "Result[Int, @postgres.PgError]"
    ":execlastid" => "Result[Int64, @postgres.PgError]"
    _ => "Result[Unit, @postgres.PgError]"
  }

  // Doc comment
  buf.write_string("///| ")
  buf.write_string(query.name)
  buf.write_string("\n")
  buf.write_string("/// ")
  buf.write_string(sanitize_newlines(query.text))
  buf.write_string("\n")

  // Function signature - sync with Connection type from mattn/postgres
  buf.write_string("pub fn ")
  buf.write_string(func_name)
  buf.write_string("(conn : @postgres.Connection")
  if query.params.length() > 0 {
    buf.write_string(", params : ")
    buf.write_string(to_pascal_case(query.name))
    buf.write_string("Params")
  }
  buf.write_string(") -> ")
  buf.write_string(return_type)
  buf.write_string(" {\n")

  // Execute query with parameterized binding (safe from SQL injection)
  if query.params.length() > 0 {
    buf.write_string("  let params : Array[@postgres.Value] = [\n")
    for i, param in query.params {
      let col = param.column
      let param_name = if col.name.length() > 0 {
        to_snake_case(col.name)
      } else {
        "p" + param.number.to_string()
      }
      buf.write_string("    ")
      buf.write_string(postgres_param_to_value(col, "params." + param_name))
      if i < query.params.length() - 1 {
        buf.write_string(",")
      }
      buf.write_string("\n")
    }
    buf.write_string("  ]\n")
    buf.write_string("  let result = conn.execute(")
    buf.write_string(sql_const)
    buf.write_string(", params)\n")
  } else {
    buf.write_string("  let result = conn.query(")
    buf.write_string(sql_const)
    buf.write_string(")\n")
  }
  buf.write_string("  match result {\n")
  buf.write_string("    Err(e) => Err(e)\n")
  buf.write_string("    Ok(qr) => {\n")

  // Execute based on command type
  match query.cmd {
    ":one" => {
      buf.write_string("      let rows = qr.rows()\n")
      buf.write_string("      qr.free()\n")
      buf.write_string("      if rows.length() == 0 {\n")
      buf.write_string("        Ok(None)\n")
      buf.write_string("      } else {\n")
      buf.write_string("        let row = rows[0]\n")
      buf.write_string("        Ok(Some({\n")
      for i, col in query.columns {
        buf.write_string("          ")
        buf.write_string(to_snake_case(col.name))
        buf.write_string(": ")
        buf.write_string(postgres_column_from_row(col, i))
        buf.write_string(",\n")
      }
      buf.write_string("        }))\n")
      buf.write_string("      }\n")
    }
    ":many" => {
      buf.write_string("      let rows = qr.rows()\n")
      buf.write_string("      qr.free()\n")
      buf.write_string("      let results : Array[")
      buf.write_string(row_type)
      buf.write_string("] = []\n")
      buf.write_string("      for row in rows {\n")
      buf.write_string("        results.push({\n")
      for i, col in query.columns {
        buf.write_string("          ")
        buf.write_string(to_snake_case(col.name))
        buf.write_string(": ")
        buf.write_string(postgres_column_from_row(col, i))
        buf.write_string(",\n")
      }
      buf.write_string("        })\n")
      buf.write_string("      }\n")
      buf.write_string("      Ok(results)\n")
    }
    ":execrows" => {
      buf.write_string("      let count = qr.affected_rows()\n")
      buf.write_string("      qr.free()\n")
      buf.write_string("      Ok(count)\n")
    }
    ":execlastid" => {
      buf.write_string(
        "      // For INSERT RETURNING, get the returned id from first row\n",
      )
      buf.write_string("      let rows = qr.rows()\n")
      buf.write_string("      qr.free()\n")
      buf.write_string("      if rows.length() > 0 && rows[0].length() > 0 {\n")
      buf.write_string(
        "        Ok(try { @strconv.parse_int64(rows[0][0]) } catch { _ => 0L })\n",
      )
      buf.write_string("      } else {\n")
      buf.write_string("        Ok(0L)\n")
      buf.write_string("      }\n")
    }
    _ => {
      // :exec
      buf.write_string("      qr.free()\n")
      buf.write_string("      Ok(())\n")
    }
  }
  buf.write_string("    }\n")
  buf.write_string("  }\n")
  buf.write_string("}\n\n")
}

///|
fn postgres_param_to_value(col : @plugin.Column, expr : String) -> String {
  let type_name = col.type_.name.to_upper()
  let is_nullable = not(col.not_null)

  // Check type category using contains matching (handles VARCHAR(255), pg_catalog.varchar, etc.)
  let is_string_type = type_name.contains("TEXT") ||
    type_name.contains("VARCHAR") ||
    type_name.contains("CHAR") ||
    type_name.contains("CHARACTER") ||
    type_name.contains("BPCHAR") ||
    type_name.contains("CLOB")
  let is_int_type = type_name == "INTEGER" ||
    type_name == "INT" ||
    type_name == "INT4" ||
    type_name == "INT2" ||
    type_name == "SMALLINT"
  let is_bigint_type = type_name == "INT8" ||
    type_name == "BIGINT" ||
    type_name.contains("SERIAL")
  let is_float_type = type_name.contains("REAL") ||
    type_name.contains("FLOAT") ||
    type_name.contains("DOUBLE") ||
    type_name.contains("NUMERIC") ||
    type_name.contains("DECIMAL")
  let is_bool_type = type_name.contains("BOOL")
  if is_nullable {
    // For nullable types, handle Option -> convert to Value or Null
    if is_string_type ||
      is_int_type ||
      is_bigint_type ||
      is_float_type ||
      is_bool_type {
      "(match " +
      expr +
      " { Some(v) => @postgres.ToValue::to_value(v); None => @postgres.Value::Null })"
    } else {
      // Unknown type - convert to string first
      "(match " +
      expr +
      " { Some(v) => @postgres.ToValue::to_value(v.to_string()); None => @postgres.Value::Null })"
    }
    // Use @postgres.ToValue::to_value() to call trait method for non-nullable types
  } else if is_string_type ||
    is_int_type ||
    is_bigint_type ||
    is_float_type ||
    is_bool_type {
    "@postgres.ToValue::to_value(" + expr + ")"
  } else {
    // Unknown type - convert to string first
    "@postgres.ToValue::to_value(" + expr + ".to_string())"
  }
}

///|
fn postgres_column_from_row(col : @plugin.Column, idx : Int) -> String {
  let type_name = col.type_.name.to_upper()
  let idx_str = idx.to_string()
  let is_nullable = not(col.not_null)

  // mattn/postgres returns Array[Array[String]], so we access row[idx]
  // and convert from String to the appropriate type
  // Note: parse_int64/parse_double raise exceptions, so we use try/catch with default
  let conversion = match type_name {
    "INTEGER" | "INT" | "INT4" =>
      "(try { @strconv.parse_int64(row[" + idx_str + "]) } catch { _ => 0L })"
    "INT2" | "SMALLINT" =>
      "(try { @strconv.parse_int(row[" + idx_str + "]) } catch { _ => 0 })"
    "INT8" | "BIGINT" | "SERIAL" | "BIGSERIAL" =>
      "(try { @strconv.parse_int64(row[" + idx_str + "]) } catch { _ => 0L })"
    "REAL" | "FLOAT4" =>
      "(try { @strconv.parse_double(row[" + idx_str + "]) } catch { _ => 0.0 })"
    "DOUBLE PRECISION" | "FLOAT8" | "FLOAT" | "NUMERIC" | "DECIMAL" =>
      "(try { @strconv.parse_double(row[" + idx_str + "]) } catch { _ => 0.0 })"
    "TEXT"
    | "VARCHAR"
    | "CHAR"
    | "CHARACTER"
    | "CHARACTER VARYING"
    | "BPCHAR" => "row[" + idx_str + "]"
    "BOOLEAN" | "BOOL" =>
      "(row[" + idx_str + "] == \"t\" || row[" + idx_str + "] == \"true\")"
    "TIMESTAMP"
    | "TIMESTAMPTZ"
    | "TIMESTAMP WITHOUT TIME ZONE"
    | "TIMESTAMP WITH TIME ZONE" => "row[" + idx_str + "]"
    "DATE" => "row[" + idx_str + "]"
    "TIME" | "TIMETZ" | "TIME WITHOUT TIME ZONE" | "TIME WITH TIME ZONE" =>
      "row[" + idx_str + "]"
    "UUID" => "row[" + idx_str + "]"
    "JSONB" | "JSON" => "row[" + idx_str + "]"
    "BYTEA" => "row[" + idx_str + "]"
    "INET" | "CIDR" | "MACADDR" | "MACADDR8" => "row[" + idx_str + "]"
    _ => "row[" + idx_str + "]"
  }

  // Wrap in Option if nullable
  if is_nullable {
    "(if row[" +
    idx_str +
    "].length() == 0 { None } else { Some(" +
    conversion +
    ") })"
  } else {
    conversion
  }
}
