// PostgreSQL JS backend (js target, using mizchi/npm_typed/pg)

///|
pub fn generate_queries_postgres_js(
  request : @plugin.GenerateRequest,
  overrides : Array[TypeOverride],
) -> String {
  let buf = StringBuilder::new()
  buf.write_string("// Generated by sqlc-gen-moonbit (backend: postgres_js)\n")
  buf.write_string("// Requires: mizchi/npm_typed/pg\n\n")

  // Generate helper functions for Int64 conversion
  buf.write_string("///| Convert JavaScript number to Int64\n")
  buf.write_string(
    "extern \"js\" fn js_number_to_int64(v : @core.Any) -> Int64 =\n",
  )
  buf.write_string(
    "  #| (v) => { const n = Number(v); return { hi: Math.floor(n / 0x100000000), lo: n >>> 0 }; }\n\n",
  )
  buf.write_string("///| Convert Int64 to JavaScript number\n")
  buf.write_string(
    "extern \"js\" fn int64_to_js_number(v : Int64) -> @core.Any =\n",
  )
  buf.write_string("  #| (v) => v.hi * 0x100000000 + (v.lo >>> 0)\n\n")

  // Generate query functions using pg Pool type
  buf.write_string("// Query functions\n")
  for query in request.queries {
    generate_query_function_postgres_js(buf, query, overrides)
  }
  buf.to_string()
}

///|
fn generate_query_function_postgres_js(
  buf : StringBuilder,
  query : @plugin.Query,
  _overrides : Array[TypeOverride],
) -> Unit {
  let func_name = to_snake_case(query.name)
  let sql_const = to_snake_case(query.name) + "_sql"
  let row_type = to_pascal_case(query.name) + "Row"
  let param_count = query.params.length()

  // Return type with async
  let return_type = match query.cmd {
    ":one" => row_type + "?"
    ":many" => "Array[" + row_type + "]"
    ":execrows" => "Int"
    ":execlastid" => "Int64"
    _ => "Unit"
  }

  // Doc comment
  buf.write_string("///| ")
  buf.write_string(query.name)
  buf.write_string("\n")
  buf.write_string("/// ")
  buf.write_string(sanitize_newlines(query.text))
  buf.write_string("\n")

  // Function signature - async with Pool type from mizchi/npm_typed/pg
  buf.write_string("pub async fn ")
  buf.write_string(func_name)
  buf.write_string("(pool : @pg.Pool")
  if param_count > 0 {
    buf.write_string(", params : ")
    buf.write_string(to_pascal_case(query.name))
    buf.write_string("Params")
  }
  buf.write_string(") -> ")
  buf.write_string(return_type)
  buf.write_string(" {\n")

  // Execute query with parameters
  buf.write_string("  let result = pool.query(")
  buf.write_string(sql_const)
  if param_count > 0 {
    buf.write_string(", params=[")
    for i, param in query.params {
      let col = param.column
      let param_name = if col.name.length() > 0 {
        to_snake_case(col.name)
      } else {
        "p" + param.number.to_string()
      }
      if i > 0 {
        buf.write_string(", ")
      }
      buf.write_string(postgres_js_param_to_any(col, "params." + param_name))
    }
    buf.write_string("]")
  }
  buf.write_string(")\n")

  // Process result based on command type
  match query.cmd {
    ":one" => {
      buf.write_string("  let rows = result.rows()\n")
      buf.write_string("  let len : Int = rows[\"length\"].cast()\n")
      buf.write_string("  if len == 0 {\n")
      buf.write_string("    None\n")
      buf.write_string("  } else {\n")
      buf.write_string("    let row = rows._get_by_index(0)\n")
      buf.write_string("    Some({\n")
      for col in query.columns {
        buf.write_string("      ")
        buf.write_string(to_snake_case(col.name))
        buf.write_string(": ")
        buf.write_string(postgres_js_column_from_any(col, "row"))
        buf.write_string(",\n")
      }
      buf.write_string("    })\n")
      buf.write_string("  }\n")
    }
    ":many" => {
      buf.write_string("  let rows = result.rows()\n")
      buf.write_string("  let len : Int = rows[\"length\"].cast()\n")
      buf.write_string("  let results : Array[")
      buf.write_string(row_type)
      buf.write_string("] = []\n")
      buf.write_string("  for i = 0; i < len; i = i + 1 {\n")
      buf.write_string("    let row = rows._get_by_index(i)\n")
      buf.write_string("    results.push({\n")
      for col in query.columns {
        buf.write_string("      ")
        buf.write_string(to_snake_case(col.name))
        buf.write_string(": ")
        buf.write_string(postgres_js_column_from_any(col, "row"))
        buf.write_string(",\n")
      }
      buf.write_string("    })\n")
      buf.write_string("  }\n")
      buf.write_string("  results\n")
    }
    ":execrows" => buf.write_string("  result.rowCount()\n")
    ":execlastid" => {
      // For INSERT RETURNING, get the returned id from first row
      buf.write_string("  let rows = result.rows()\n")
      buf.write_string("  let len : Int = rows[\"length\"].cast()\n")
      buf.write_string("  if len > 0 {\n")
      buf.write_string("    let row = rows._get_by_index(0)\n")
      // Assume first column is the id
      buf.write_string("    js_number_to_int64(row[\"id\"])\n")
      buf.write_string("  } else {\n")
      buf.write_string("    0L\n")
      buf.write_string("  }\n")
    }
    _ =>
      // :exec
      buf.write_string("  ignore(result)\n")
  }
  buf.write_string("}\n\n")
}

///|
fn postgres_js_param_to_any(col : @plugin.Column, expr : String) -> String {
  let type_name = col.type_.name.to_upper()
  let is_nullable = not(col.not_null)
  let is_int64 = type_name == "INTEGER" ||
    type_name == "INT" ||
    type_name == "INT4" ||
    type_name == "INT8" ||
    type_name == "BIGINT" ||
    type_name == "SERIAL" ||
    type_name == "BIGSERIAL"
  if is_nullable {
    // For nullable types, handle Option - convert None to @core.null()
    if is_int64 {
      "(match " +
      expr +
      " { Some(v) => int64_to_js_number(v); None => @core.null() })"
    } else {
      "(match " + expr + " { Some(v) => @core.any(v); None => @core.null() })"
    }
  } else if is_int64 {
    "int64_to_js_number(" + expr + ")"
  } else {
    "@core.any(" + expr + ")"
  }
}

///|
fn postgres_js_column_from_any(
  col : @plugin.Column,
  obj_expr : String,
) -> String {
  let type_name = col.type_.name.to_upper()
  let field_name = "\"" + col.name + "\""
  let field_access = obj_expr + "[" + field_name + "]"

  // Handle nullable columns
  if not(col.not_null) {
    // For nullable columns, check for null/undefined first
    match type_name {
      "INTEGER" | "INT" | "INT4" =>
        "(if @core.is_null(" +
        field_access +
        ") || @core.typeof_(" +
        field_access +
        ") == \"undefined\" { None } else { Some(js_number_to_int64(" +
        field_access +
        ")) })"
      "INT2" | "SMALLINT" =>
        "(if @core.is_null(" +
        field_access +
        ") || @core.typeof_(" +
        field_access +
        ") == \"undefined\" { None } else { Some(" +
        field_access +
        ".cast()) })"
      "INT8" | "BIGINT" | "SERIAL" | "BIGSERIAL" =>
        "(if @core.is_null(" +
        field_access +
        ") || @core.typeof_(" +
        field_access +
        ") == \"undefined\" { None } else { Some(js_number_to_int64(" +
        field_access +
        ")) })"
      _ =>
        "(if @core.is_null(" +
        field_access +
        ") || @core.typeof_(" +
        field_access +
        ") == \"undefined\" { None } else { Some(" +
        field_access +
        ".cast()) })"
    }
  } else {
    // Non-nullable columns
    match type_name {
      "INTEGER" | "INT" | "INT4" => "js_number_to_int64(" + field_access + ")"
      "INT2" | "SMALLINT" => field_access + ".cast()"
      "INT8" | "BIGINT" | "SERIAL" | "BIGSERIAL" =>
        "js_number_to_int64(" + field_access + ")"
      _ => field_access + ".cast()"
    }
  }
}
