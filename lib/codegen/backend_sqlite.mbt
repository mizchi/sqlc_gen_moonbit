// SQLite backend (native target, low-level API)

///|
pub fn generate_queries_sqlite(
  request : @plugin.GenerateRequest,
  overrides : Array[TypeOverride],
) -> String {
  let buf = StringBuilder::new()
  buf.write_string("// Generated by sqlc-gen-moonbit (backend: sqlite)\n\n")

  // Generate helper functions for SQLite
  buf.write_string("///|\nfn cstring(s : String) -> Bytes {\n")
  buf.write_string("  @encoding.encode(@encoding.UTF8, s)\n")
  buf.write_string("}\n\n")
  buf.write_string("///|\nfn bytes_to_string(b : Bytes) -> String {\n")
  buf.write_string("  let decoder = @encoding.decoder(@encoding.UTF8)\n")
  buf.write_string("  decoder.decode_lossy(b[0:b.length()])\n")
  buf.write_string("}\n\n")

  // Generate helper function for checking SQLite errors
  buf.write_string(
    "///|\nfn check_sqlite_error(db : @sqlite.Sqlite3, rc : Int) -> Unit raise SqlError {\n",
  )
  buf.write_string(
    "  if rc != @sqlite.SQLITE_ROW && rc != @sqlite.SQLITE_DONE {\n",
  )
  buf.write_string("    let msg = bytes_to_string(@sqlite.sqlite_errmsg(db))\n")
  buf.write_string("    raise SqlError(msg)\n")
  buf.write_string("  }\n")
  buf.write_string("}\n\n")

  // Generate query functions
  buf.write_string("// Query functions\n")
  for query in request.queries {
    generate_query_function_sqlite(buf, query, overrides)
  }
  buf.to_string()
}

///|
fn generate_query_function_sqlite(
  buf : StringBuilder,
  query : @plugin.Query,
  _overrides : Array[TypeOverride],
) -> Unit {
  let func_name = to_snake_case(query.name)
  let sql_const = to_snake_case(query.name) + "_sql"
  let row_type = to_pascal_case(query.name) + "Row"

  // Return type with error handling
  let return_type = match query.cmd {
    ":one" => row_type + "?"
    ":many" => "Array[" + row_type + "]"
    ":execrows" => "Int"
    ":execlastid" => "Int64"
    _ => "Unit"
  }

  // Doc comment
  buf.write_string("///| ")
  buf.write_string(query.name)
  buf.write_string("\n")
  buf.write_string("/// ")
  buf.write_string(sanitize_newlines(query.text))
  buf.write_string("\n")

  // Function signature - use low-level Sqlite3 type with raise SqlError
  buf.write_string("pub fn ")
  buf.write_string(func_name)
  buf.write_string("(db : @sqlite.Sqlite3")
  if query.params.length() > 0 {
    buf.write_string(", params : ")
    buf.write_string(to_pascal_case(query.name))
    buf.write_string("Params")
  }
  buf.write_string(") -> ")
  buf.write_string(return_type)
  buf.write_string(" raise SqlError {\n")

  // Prepare statement using low-level API
  buf.write_string("  let stmt = @sqlite.sqlite_prepare(db, cstring(")
  buf.write_string(sql_const)
  buf.write_string("))\n")

  // Bind parameters using low-level sqlite_bind_* functions
  if query.params.length() > 0 {
    for i, param in query.params {
      let col = param.column
      let param_name = if col.name.length() > 0 {
        to_snake_case(col.name)
      } else {
        "p" + param.number.to_string()
      }
      buf.write_string("  ")
      buf.write_string(
        sqlite_param_to_bind_call(col, i + 1, "params." + param_name),
      )
      buf.write_string(" |> ignore\n")
    }
  }

  // Execute based on command type using low-level API
  match query.cmd {
    ":one" => {
      buf.write_string("  let rc = @sqlite.sqlite_step(stmt)\n")
      buf.write_string("  if rc == @sqlite.SQLITE_ROW {\n")
      buf.write_string("    let row : ")
      buf.write_string(row_type)
      buf.write_string(" = {\n")
      for i, col in query.columns {
        buf.write_string("      ")
        buf.write_string(to_snake_case(col.name))
        buf.write_string(": ")
        buf.write_string(sqlite_column_to_moonbit(col, i))
        buf.write_string(",\n")
      }
      buf.write_string("    }\n")
      buf.write_string("    @sqlite.sqlite_finalize(stmt)\n")
      buf.write_string("    Some(row)\n")
      buf.write_string("  } else if rc == @sqlite.SQLITE_DONE {\n")
      buf.write_string("    @sqlite.sqlite_finalize(stmt)\n")
      buf.write_string("    None\n")
      buf.write_string("  } else {\n")
      buf.write_string("    @sqlite.sqlite_finalize(stmt)\n")
      buf.write_string("    check_sqlite_error(db, rc)\n")
      buf.write_string("    None\n")
      buf.write_string("  }\n")
    }
    ":many" => {
      buf.write_string("  let results : Array[")
      buf.write_string(row_type)
      buf.write_string("] = []\n")
      buf.write_string("  while true {\n")
      buf.write_string("    let rc = @sqlite.sqlite_step(stmt)\n")
      buf.write_string("    if rc == @sqlite.SQLITE_ROW {\n")
      buf.write_string("      let row : ")
      buf.write_string(row_type)
      buf.write_string(" = {\n")
      for i, col in query.columns {
        buf.write_string("        ")
        buf.write_string(to_snake_case(col.name))
        buf.write_string(": ")
        buf.write_string(sqlite_column_to_moonbit(col, i))
        buf.write_string(",\n")
      }
      buf.write_string("      }\n")
      buf.write_string("      results.push(row)\n")
      buf.write_string("    } else if rc == @sqlite.SQLITE_DONE {\n")
      buf.write_string("      break\n")
      buf.write_string("    } else {\n")
      buf.write_string("      @sqlite.sqlite_finalize(stmt)\n")
      buf.write_string("      check_sqlite_error(db, rc)\n")
      buf.write_string("      break\n")
      buf.write_string("    }\n")
      buf.write_string("  }\n")
      buf.write_string("  @sqlite.sqlite_finalize(stmt)\n")
      buf.write_string("  results\n")
    }
    ":execrows" => {
      buf.write_string("  let rc = @sqlite.sqlite_step(stmt)\n")
      buf.write_string("  @sqlite.sqlite_finalize(stmt)\n")
      buf.write_string("  check_sqlite_error(db, rc)\n")
      buf.write_string("  @sqlite.sqlite_changes(db)\n")
    }
    ":execlastid" => {
      buf.write_string("  let rc = @sqlite.sqlite_step(stmt)\n")
      buf.write_string("  @sqlite.sqlite_finalize(stmt)\n")
      buf.write_string("  check_sqlite_error(db, rc)\n")
      buf.write_string("  @sqlite.sqlite_last_insert_rowid(db)\n")
    }
    _ => {
      // :exec
      buf.write_string("  let rc = @sqlite.sqlite_step(stmt)\n")
      buf.write_string("  @sqlite.sqlite_finalize(stmt)\n")
      buf.write_string("  check_sqlite_error(db, rc)\n")
    }
  }
  buf.write_string("}\n\n")
}

///|
fn sqlite_param_to_bind_call(
  col : @plugin.Column,
  idx : Int,
  expr : String,
) -> String {
  let type_name = col.type_.name.to_upper()
  let idx_str = idx.to_string()
  let is_nullable = not(col.not_null)

  // Get the base bind call expression
  let base_bind = fn(val_expr : String) -> String {
    match type_name {
      "INTEGER" | "INT" | "INT4" | "SMALLINT" =>
        "@sqlite.sqlite_bind_int64(stmt, " + idx_str + ", " + val_expr + ")"
      "INT8" | "BIGINT" =>
        "@sqlite.sqlite_bind_int64(stmt, " + idx_str + ", " + val_expr + ")"
      "REAL" | "FLOAT" | "DOUBLE" | "NUMERIC" | "DECIMAL" =>
        "@sqlite.sqlite_bind_double(stmt, " + idx_str + ", " + val_expr + ")"
      "TEXT" | "VARCHAR" | "CHAR" | "CHARACTER" | "CLOB" =>
        "@sqlite.sqlite_bind_text(stmt, " +
        idx_str +
        ", cstring(" +
        val_expr +
        "))"
      "BLOB" | "BYTEA" =>
        "@sqlite.sqlite_bind_blob(stmt, " + idx_str + ", " + val_expr + ")"
      "BOOLEAN" | "BOOL" =>
        "@sqlite.sqlite_bind_int(stmt, " +
        idx_str +
        ", if " +
        val_expr +
        " { 1 } else { 0 })"
      _ =>
        "@sqlite.sqlite_bind_text(stmt, " +
        idx_str +
        ", cstring(" +
        val_expr +
        "))"
    }
  }

  // Handle nullable parameters with match
  if is_nullable {
    "(match " +
    expr +
    " { None => @sqlite.sqlite_bind_null(stmt, " +
    idx_str +
    "); Some(v) => " +
    base_bind("v") +
    " })"
  } else {
    base_bind(expr)
  }
}

///|
fn sqlite_column_to_moonbit(col : @plugin.Column, idx : Int) -> String {
  let type_name = col.type_.name.to_upper()
  let idx_str = idx.to_string()
  let is_nullable = not(col.not_null)

  // Get the base value expression
  let base_expr = match type_name {
    "INTEGER" | "INT" | "INT4" | "INT8" | "BIGINT" | "SMALLINT" =>
      "@sqlite.sqlite_column_int64(stmt, " + idx_str + ")"
    "REAL" | "FLOAT" | "DOUBLE" | "NUMERIC" | "DECIMAL" =>
      "@sqlite.sqlite_column_double(stmt, " + idx_str + ")"
    "TEXT" | "VARCHAR" | "CHAR" | "CHARACTER" | "CLOB" =>
      "bytes_to_string(@sqlite.sqlite_column_text(stmt, " + idx_str + "))"
    "BLOB" | "BYTEA" => "@sqlite.sqlite_column_blob(stmt, " + idx_str + ")"
    "BOOLEAN" | "BOOL" =>
      "@sqlite.sqlite_column_int(stmt, " + idx_str + ") != 0"
    _ => "bytes_to_string(@sqlite.sqlite_column_text(stmt, " + idx_str + "))"
  }

  // Wrap in Option if nullable
  if is_nullable {
    "(if @sqlite.sqlite_column_type(stmt, " +
    idx_str +
    ") == @sqlite.SQLITE_NULL { None } else { Some(" +
    base_expr +
    ") })"
  } else {
    base_expr
  }
}
