// SQLite JS backend (js target, high-level API)

///|
pub fn generate_queries_sqlite_js(
  request : @plugin.GenerateRequest,
  overrides : Array[TypeOverride],
) -> String {
  let buf = StringBuilder::new()
  buf.write_string("// Generated by sqlc-gen-moonbit (backend: sqlite_js)\n")
  buf.write_string("// Requires: mizchi/sqlite (JS target)\n\n")

  // Generate helper functions for high-level SQLite JS API
  buf.write_string("///|\nfn bytes_to_string(b : Bytes) -> String {\n")
  buf.write_string("  let decoder = @encoding.decoder(@encoding.UTF8)\n")
  buf.write_string("  decoder.decode_lossy(b[0:b.length()])\n")
  buf.write_string("}\n\n")

  // Generate query functions using high-level API
  buf.write_string("// Query functions\n")
  for query in request.queries {
    generate_query_function_sqlite_js(buf, query, overrides)
  }
  buf.to_string()
}

///|
fn generate_query_function_sqlite_js(
  buf : StringBuilder,
  query : @plugin.Query,
  _overrides : Array[TypeOverride],
) -> Unit {
  let func_name = to_snake_case(query.name)
  let sql_const = to_snake_case(query.name) + "_sql"
  let row_type = to_pascal_case(query.name) + "Row"

  // Return type with error handling (using Option for JS API errors)
  let return_type = match query.cmd {
    ":one" => row_type + "?"
    ":many" => "Array[" + row_type + "]"
    ":execrows" => "Int"
    ":execlastid" => "Int64"
    _ => "Unit"
  }

  // Doc comment
  buf.write_string("///| ")
  buf.write_string(query.name)
  buf.write_string("\n")
  buf.write_string("/// ")
  buf.write_string(sanitize_newlines(query.text))
  buf.write_string("\n")

  // Function signature - use high-level Database type with raise SqlError
  buf.write_string("pub fn ")
  buf.write_string(func_name)
  buf.write_string("(db : @sqlite.Database")
  if query.params.length() > 0 {
    buf.write_string(", params : ")
    buf.write_string(to_pascal_case(query.name))
    buf.write_string("Params")
  }
  buf.write_string(") -> ")
  buf.write_string(return_type)
  buf.write_string(" raise SqlError {\n")

  // Prepare statement using high-level API
  buf.write_string("  let stmt = match db.prepare(")
  buf.write_string(sql_const)
  buf.write_string(") {\n")
  buf.write_string("    Some(s) => s\n")
  buf.write_string("    None => raise SqlError(bytes_to_string(db.errmsg()))\n")
  buf.write_string("  }\n")

  // Bind parameters using high-level bind API
  if query.params.length() > 0 {
    for i, param in query.params {
      let col = param.column
      let param_name = if col.name.length() > 0 {
        to_snake_case(col.name)
      } else {
        "p" + param.number.to_string()
      }
      buf.write_string("  stmt.bind(")
      buf.write_string((i + 1).to_string())
      buf.write_string(", ")
      buf.write_string(sqlite_js_param_to_sql_value(col, "params." + param_name))
      buf.write_string(") |> ignore\n")
    }
  }

  // Execute based on command type using high-level API
  match query.cmd {
    ":one" => {
      buf.write_string("  if stmt.step() {\n")
      buf.write_string("    let row : ")
      buf.write_string(row_type)
      buf.write_string(" = {\n")
      for i, col in query.columns {
        buf.write_string("      ")
        buf.write_string(to_snake_case(col.name))
        buf.write_string(": ")
        buf.write_string(sqlite_js_column_from_sql_value(col, i))
        buf.write_string(",\n")
      }
      buf.write_string("    }\n")
      buf.write_string("    stmt.finalize()\n")
      buf.write_string("    Some(row)\n")
      buf.write_string("  } else {\n")
      buf.write_string("    stmt.finalize()\n")
      buf.write_string("    None\n")
      buf.write_string("  }\n")
    }
    ":many" => {
      buf.write_string("  let results : Array[")
      buf.write_string(row_type)
      buf.write_string("] = []\n")
      buf.write_string("  while stmt.step() {\n")
      buf.write_string("    let row : ")
      buf.write_string(row_type)
      buf.write_string(" = {\n")
      for i, col in query.columns {
        buf.write_string("      ")
        buf.write_string(to_snake_case(col.name))
        buf.write_string(": ")
        buf.write_string(sqlite_js_column_from_sql_value(col, i))
        buf.write_string(",\n")
      }
      buf.write_string("    }\n")
      buf.write_string("    results.push(row)\n")
      buf.write_string("  }\n")
      buf.write_string("  stmt.finalize()\n")
      buf.write_string("  results\n")
    }
    ":execrows" => {
      buf.write_string("  stmt.execute() |> ignore\n")
      buf.write_string("  stmt.finalize()\n")
      buf.write_string("  db.changes()\n")
    }
    ":execlastid" => {
      buf.write_string("  stmt.execute() |> ignore\n")
      buf.write_string("  stmt.finalize()\n")
      buf.write_string("  db.last_insert_rowid()\n")
    }
    _ => {
      // :exec
      buf.write_string("  stmt.execute() |> ignore\n")
      buf.write_string("  stmt.finalize()\n")
    }
  }
  buf.write_string("}\n\n")
}

///|
fn sqlite_js_param_to_sql_value(col : @plugin.Column, expr : String) -> String {
  let type_name = col.type_.name.to_upper()
  let is_nullable = not(col.not_null)

  if is_nullable {
    // For nullable types, handle Option
    match type_name {
      "INTEGER" | "INT" | "INT4" | "INT2" | "SMALLINT" =>
        "(match " + expr + " { Some(v) => @sqlite.Int(v); None => @sqlite.Null })"
      "INT8" | "BIGINT" =>
        "(match " + expr + " { Some(v) => @sqlite.Int64(v); None => @sqlite.Null })"
      "REAL" | "FLOAT" | "DOUBLE" | "NUMERIC" | "DECIMAL" =>
        "(match " + expr + " { Some(v) => @sqlite.Double(v); None => @sqlite.Null })"
      "TEXT" | "VARCHAR" | "CHAR" | "CHARACTER" | "CLOB" =>
        "(match " + expr + " { Some(v) => @sqlite.Text(@encoding.encode(@encoding.UTF8, v)); None => @sqlite.Null })"
      "BLOB" | "BYTEA" =>
        "(match " + expr + " { Some(v) => @sqlite.Blob(v); None => @sqlite.Null })"
      "BOOLEAN" | "BOOL" =>
        "(match " + expr + " { Some(v) => @sqlite.Int(if v { 1 } else { 0 }); None => @sqlite.Null })"
      _ =>
        "(match " + expr + " { Some(v) => @sqlite.Text(@encoding.encode(@encoding.UTF8, v.to_string())); None => @sqlite.Null })"
    }
  } else {
    match type_name {
      "INTEGER" | "INT" | "INT4" | "INT2" | "SMALLINT" =>
        "@sqlite.Int(" + expr + ")"
      "INT8" | "BIGINT" =>
        "@sqlite.Int64(" + expr + ")"
      "REAL" | "FLOAT" | "DOUBLE" | "NUMERIC" | "DECIMAL" =>
        "@sqlite.Double(" + expr + ")"
      "TEXT" | "VARCHAR" | "CHAR" | "CHARACTER" | "CLOB" =>
        "@sqlite.Text(@encoding.encode(@encoding.UTF8, " + expr + "))"
      "BLOB" | "BYTEA" =>
        "@sqlite.Blob(" + expr + ")"
      "BOOLEAN" | "BOOL" =>
        "@sqlite.Int(if " + expr + " { 1 } else { 0 })"
      _ =>
        "@sqlite.Text(@encoding.encode(@encoding.UTF8, " + expr + ".to_string()))"
    }
  }
}

///|
fn sqlite_js_column_from_sql_value(col : @plugin.Column, idx : Int) -> String {
  let type_name = col.type_.name.to_upper()
  let idx_str = idx.to_string()
  let is_nullable = not(col.not_null)

  // Use high-level Statement::column which returns SqlValue
  let base_expr = match type_name {
    "INTEGER" | "INT" | "INT4" | "SMALLINT" =>
      "stmt.column_int(" + idx_str + ")"
    "INT8" | "BIGINT" =>
      // column_int returns Int, need to convert to Int64
      "stmt.column_int(" + idx_str + ").to_int64()"
    "REAL" | "FLOAT" | "DOUBLE" | "NUMERIC" | "DECIMAL" =>
      // Use column and extract Double from SqlValue
      "(match stmt.column(" + idx_str + ") { @sqlite.Double(v) => v; @sqlite.Int(v) => v.to_double(); _ => 0.0 })"
    "TEXT" | "VARCHAR" | "CHAR" | "CHARACTER" | "CLOB" =>
      "bytes_to_string(stmt.column_text(" + idx_str + "))"
    "BLOB" | "BYTEA" =>
      "stmt.column_text(" + idx_str + ")"
    "BOOLEAN" | "BOOL" =>
      "stmt.column_int(" + idx_str + ") != 0"
    _ =>
      "bytes_to_string(stmt.column_text(" + idx_str + "))"
  }

  // Wrap in Option if nullable
  if is_nullable {
    "(match stmt.column(" + idx_str + ") { @sqlite.Null => None; _ => Some(" + base_expr + ") })"
  } else {
    base_expr
  }
}
