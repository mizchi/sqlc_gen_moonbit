// Backend trait for abstracting database-specific code generation

///|
pub struct BackendInfo {
  name : String // "sqlite", "d1", etc.
  db_type : String // "@sqlite.Sqlite3", "@cloudflare.D1Database", etc.
  error_type : String? // None = no error, Some("SqlError"), Some("@cloudflare.D1Error")
  uses_result : Bool // true if returns Result[T, E] instead of raise
  is_async : Bool
  target : String // "native", "js"
}

///|
pub fn BackendInfo::new(
  name : String,
  db_type : String,
  error_type : String?,
  uses_result : Bool,
  is_async : Bool,
  target : String,
) -> BackendInfo {
  { name, db_type, error_type, uses_result, is_async, target }
}

///|
/// Trait for backend code generation
pub trait BackendCodeGen {
  /// Get backend metadata
  info(Self) -> BackendInfo

  /// Generate helper functions (cstring, bytes_to_string, etc.)
  generate_helpers(Self, StringBuilder) -> Unit

  /// Generate parameter binding expression
  /// Returns MoonBit code that binds a parameter value
  param_bind_expr(Self, @plugin.Column, Int, String) -> String

  /// Generate column read expression
  /// Returns MoonBit code that reads a column value
  column_read_expr(Self, @plugin.Column, Int, String) -> String

  /// Generate the full query function for :one command
  generate_one(Self, StringBuilder, @plugin.Query, Array[TypeOverride]) -> Unit

  /// Generate the full query function for :many command
  generate_many(Self, StringBuilder, @plugin.Query, Array[TypeOverride]) -> Unit

  /// Generate the full query function for :exec command
  generate_exec(Self, StringBuilder, @plugin.Query, Array[TypeOverride]) -> Unit

  /// Generate the full query function for :execrows command
  generate_execrows(Self, StringBuilder, @plugin.Query, Array[TypeOverride]) -> Unit

  /// Generate the full query function for :execlastid command
  generate_execlastid(Self, StringBuilder, @plugin.Query, Array[TypeOverride]) -> Unit
}

///|
/// Generate queries using the BackendCodeGen trait
pub fn[B : BackendCodeGen] generate_queries_with_backend(
  backend : B,
  request : @plugin.GenerateRequest,
  overrides : Array[TypeOverride],
) -> String {
  let buf = StringBuilder::new()
  let info = backend.info()

  // Header comment
  buf.write_string("// Generated by sqlc-gen-moonbit (backend: ")
  buf.write_string(info.name)
  buf.write_string(")\n\n")

  // Generate helper functions
  backend.generate_helpers(buf)

  // Generate query functions
  buf.write_string("// Query functions\n")
  for query in request.queries {
    match query.cmd {
      ":one" => backend.generate_one(buf, query, overrides)
      ":many" => backend.generate_many(buf, query, overrides)
      ":execrows" => backend.generate_execrows(buf, query, overrides)
      ":execlastid" => backend.generate_execlastid(buf, query, overrides)
      _ => backend.generate_exec(buf, query, overrides)
    }
  }
  buf.to_string()
}

// ============================================================
// Shared helper functions for backend implementations
// ============================================================

///|
/// Generate doc comment for a query function
fn backend_write_doc_comment(
  buf : StringBuilder,
  query : @plugin.Query,
) -> Unit {
  buf.write_string("///| ")
  buf.write_string(query.name)
  buf.write_string("\n")
  buf.write_string("/// ")
  buf.write_string(sanitize_newlines(query.text))
  buf.write_string("\n")
}

///|
/// Get function name from query
fn backend_get_func_name(query : @plugin.Query) -> String {
  to_snake_case(query.name)
}

///|
/// Get SQL constant name from query
fn backend_get_sql_const(query : @plugin.Query) -> String {
  to_snake_case(query.name) + "_sql"
}

///|
/// Get row type name from query
fn backend_get_row_type(query : @plugin.Query) -> String {
  to_pascal_case(query.name) + "Row"
}

///|
/// Get params type name from query
fn backend_get_params_type(query : @plugin.Query) -> String {
  to_pascal_case(query.name) + "Params"
}

///|
/// Get param name from column
fn backend_get_param_name(col : @plugin.Column, number : Int) -> String {
  if col.name.length() > 0 {
    to_snake_case(col.name)
  } else {
    "p" + number.to_string()
  }
}

///|
/// Generate function signature start
fn backend_write_fn_signature_start(
  buf : StringBuilder,
  info : BackendInfo,
  query : @plugin.Query,
  return_type : String,
) -> Unit {
  // pub [async] fn func_name(db : DbType
  if info.is_async {
    buf.write_string("pub async fn ")
  } else {
    buf.write_string("pub fn ")
  }
  buf.write_string(backend_get_func_name(query))
  buf.write_string("(db : ")
  buf.write_string(info.db_type)

  // , params : ParamsType
  if query.params.length() > 0 {
    buf.write_string(", params : ")
    buf.write_string(backend_get_params_type(query))
  }

  // ) -> ReturnType [raise Error] {
  buf.write_string(") -> ")
  buf.write_string(return_type)

  // Add error handling
  match info.error_type {
    Some(err) =>
      if not(info.uses_result) {
        buf.write_string(" raise ")
        buf.write_string(err)
      }
    None => ()
  }
  buf.write_string(" {\n")
}

///|
/// Get base return type for a command (without Result wrapper)
fn backend_get_base_return_type(query : @plugin.Query) -> String {
  let row_type = backend_get_row_type(query)
  match query.cmd {
    ":one" => row_type + "?"
    ":many" => "Array[" + row_type + "]"
    ":execrows" => "Int"
    ":execlastid" => "Int64"
    _ => "Unit"
  }
}

///|
/// Get full return type with Result wrapper if needed
fn backend_get_return_type(info : BackendInfo, query : @plugin.Query) -> String {
  let base = backend_get_base_return_type(query)
  if info.uses_result {
    match info.error_type {
      Some(err) => "Result[" + base + ", " + err + "]"
      None => base
    }
  } else {
    base
  }
}
