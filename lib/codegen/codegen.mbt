// Process request and generate response

///|
pub fn process_request(input : Bytes) -> Bytes {
  // Parse GenerateRequest from protobuf
  let reader = @protobuf.BytesReader::from_bytes(input)
  let request : @plugin.GenerateRequest = @protobuf.Read::read(reader) catch {
    _ => @plugin.GenerateRequest::default()
  }

  // Parse plugin options
  let options = parse_plugin_options(request.plugin_options)

  // Generate code files
  let files : Array[@plugin.File] = []

  // Generate moon.pkg (package config)
  let moon_pkg_content = generate_moon_pkg(options)
  files.push(@plugin.File::new("moon.pkg", string_to_utf8(moon_pkg_content)))

  // Generate types (backend-specific for error types)
  let types_content = generate_types(request, options)
  files.push(@plugin.File::new("sqlc_types.mbt", string_to_utf8(types_content)))

  // Generate queries (backend-specific)
  let queries_content = match options.backend {
    Sqlite => generate_queries_sqlite(request, options.overrides)
    SqliteJs => generate_queries_sqlite_js(request, options.overrides)
    D1 => generate_queries_d1(request, options.overrides)
    Postgres => generate_queries_postgres(request, options.overrides)
    PostgresJs => generate_queries_postgres_js(request, options.overrides)
    MysqlJs => generate_queries_mysql_js(request, options.overrides)
  }
  files.push(
    @plugin.File::new("sqlc_queries.mbt", string_to_utf8(queries_content)),
  )

  // Generate JSON Schema (optional) - moved before validators to avoid serialization bug
  if options.json_schema {
    let schema_content = generate_json_schema(request)
    files.push(
      @plugin.File::new("sqlc_schema.json", string_to_utf8(schema_content)),
    )
  }

  // Generate validators (optional) - last to avoid first-byte corruption
  if options.validators {
    let validators_content = generate_validators(request)
    files.push(
      @plugin.File::new(
        "sqlc_validators.mbt",
        string_to_utf8(validators_content),
      ),
    )
  }
  let response = @plugin.GenerateResponse::new(files)

  // Serialize response to protobuf
  serialize_response(response)
}

///|
fn generate_moon_pkg(options : Options) -> String {
  let buf = StringBuilder::new()
  buf.write_string("import {\n")
  match options.backend {
    Sqlite | SqliteJs => {
      buf.write_string("  \"mizchi/sqlite\",\n")
      buf.write_string("  \"moonbitlang/x/encoding\",\n")
    }
    D1 => {
      buf.write_string("  \"mizchi/js/core\",\n")
      buf.write_string("  \"mizchi/cloudflare\",\n")
    }
    Postgres => buf.write_string("  \"mattn/postgres\",\n")
    PostgresJs => {
      buf.write_string("  \"mizchi/js/core\",\n")
      buf.write_string("  \"mizchi/npm_typed/pg\",\n")
    }
    MysqlJs => {
      buf.write_string("  \"mizchi/js/core\",\n")
    }
  }
  buf.write_string("}\n\n")

  // Options block
  buf.write_string("options(\n")

  // Add supported-targets based on backend
  match options.backend {
    D1 | SqliteJs | PostgresJs | MysqlJs =>
      buf.write_string("  \"supported-targets\": [ \"js\" ],\n")
    Postgres => buf.write_string("  \"supported-targets\": [ \"native\" ],\n")
    Sqlite => ()
  }

  // Exclude generated files from formatter
  buf.write_string("  \"formatter\": {\n")
  buf.write_string("    \"ignore\": [\n")
  buf.write_string("      \"sqlc_types.mbt\",\n")
  buf.write_string("      \"sqlc_queries.mbt\",\n")
  buf.write_string("      \"sqlc_validators.mbt\"\n")
  buf.write_string("    ]\n")
  buf.write_string("  },\n")
  buf.write_string(")\n")
  buf.to_string()
}

///|
fn generate_types(
  request : @plugin.GenerateRequest,
  options : Options,
) -> String {
  let buf = StringBuilder::new()
  buf.write_string("// Generated by sqlc-gen-moonbit\n")
  buf.write_string("// sqlc version: ")
  buf.write_string(request.sqlc_version)
  buf.write_string("\n\n")

  // Define error type only for SQLite backends
  // D1 backend uses @cloudflare.D1Error directly
  // Postgres native uses @postgres.PgError directly
  // PostgresJs/MysqlJs use JS errors directly
  match options.backend {
    Sqlite | SqliteJs => {
      buf.write_string("///| SQL execution error\n")
      buf.write_string("pub suberror SqlError {\n")
      buf.write_string("  SqlError(String)\n")
      buf.write_string("} derive(Show)\n\n")
    }
    D1 | Postgres | PostgresJs | MysqlJs => ()
  }

  // Collect unique result structs from queries
  let generated_structs : Map[String, Bool] = {}

  // Generate result structs for queries that return data
  for query in request.queries {
    if query.cmd == ":one" || query.cmd == ":many" {
      let struct_name = to_pascal_case(query.name) + "Row"
      if not(generated_structs.contains(struct_name)) &&
        query.columns.length() > 0 {
        generated_structs[struct_name] = true
        generate_result_struct(
          buf,
          struct_name,
          query.columns,
          options.overrides,
        )
      }
    }
  }

  // Generate parameter structs for queries with parameters
  for query in request.queries {
    if query.params.length() > 0 {
      let struct_name = to_pascal_case(query.name) + "Params"
      generate_params_struct(buf, struct_name, query.params, options.overrides)
    }
  }

  // Generate SQL constants
  buf.write_string("// SQL queries\n")
  for query in request.queries {
    let const_name = to_snake_case(query.name) + "_sql"
    buf.write_string("pub let ")
    buf.write_string(const_name)
    buf.write_string(" : String = ")
    buf.write_string(escape_string(query.text))
    buf.write_string("\n\n")
  }
  buf.to_string()
}
