// Standalone code generator API
// Usage: moon add mizchi/sqlc_gen_moonbit
// Then call @codegen.generate_from_sql(sql_content) in your main.mbt

///|
/// Query definition for standalone generation
pub struct QueryDef {
  name : String
  cmd : String // :one, :many, :exec
  params : Array[(String, String)] // (name, type)
  returns : Array[(String, String)] // (name, type)
  sql : String
}

///|
/// Parse SQL file content with @query annotations
pub fn parse_sql_queries(content : String) -> Array[QueryDef] {
  let queries : Array[QueryDef] = []
  let lines = standalone_split_lines(content)
  let mut i = 0
  while i < lines.length() {
    let line = lines[i].trim().to_string()
    if line.has_prefix("-- @query ") {
      let parts = standalone_split_whitespace(standalone_substr(line, 10))
      if parts.length() >= 2 {
        let name = parts[0]
        let cmd = parts[1]
        let params : Array[(String, String)] = []
        let returns : Array[(String, String)] = []
        let sql_lines : Array[String] = []
        i = i + 1
        while i < lines.length() {
          let next_line = lines[i].trim().to_string()
          if next_line.has_prefix("-- @param ") {
            let param_str = standalone_substr(next_line, 10)
            let param_parts = standalone_split_whitespace(param_str)
            if param_parts.length() >= 2 {
              params.push((param_parts[0], param_parts[1]))
            }
          } else if next_line.has_prefix("-- @returns ") {
            let ret_str = standalone_substr(next_line, 12)
            let cols = standalone_split_by_comma(ret_str)
            for col in cols {
              let col_parts = standalone_split_whitespace(
                col.trim().to_string(),
              )
              if col_parts.length() >= 2 {
                returns.push((col_parts[0], col_parts[1]))
              }
            }
          } else if next_line.has_prefix("-- @query ") {
            break
          } else if next_line.length() > 0 && not(next_line.has_prefix("--")) {
            sql_lines.push(next_line)
            if next_line.has_suffix(";") {
              i = i + 1
              break
            }
          }
          i = i + 1
        }
        let sql = standalone_join_lines(sql_lines, " ")
        queries.push({ name, cmd, params, returns, sql })
        continue
      }
    }
    i = i + 1
  }
  queries
}

///|
/// Generate MoonBit code from SQL queries (using codegen.mbt)
pub fn generate_from_queries(queries : Array[QueryDef]) -> String {
  let buf = StringBuilder::new()
  buf.write_string("// Generated by sqlc-gen-moonbit using mizchi/codegen\n\n")

  // Helper functions
  buf.write_string("///|\nfn cstring(s : String) -> Bytes {\n")
  buf.write_string("  @encoding.encode(@encoding.UTF8, s)\n")
  buf.write_string("}\n\n")
  buf.write_string("///|\nfn bytes_to_string(b : Bytes) -> String {\n")
  buf.write_string("  let decoder = @encoding.decoder(@encoding.UTF8)\n")
  buf.write_string("  decoder.decode_lossy(b[0:b.length()])\n")
  buf.write_string("}\n\n")
  let emitter = @emit.MoonBitEmitter::new()
  let validator_emitter = @emit.ValidatorEmitter::new()

  // Generate structs
  for query in queries {
    if (query.cmd == ":one" || query.cmd == ":many") &&
      query.returns.length() > 0 {
      let row_struct = standalone_query_to_row_struct(query)
      buf.write_string(emitter.emit_struct(row_struct))
      buf.write_string("\n")
    }
    if query.params.length() > 0 {
      let params_struct = standalone_query_to_params_struct(query)
      buf.write_string(emitter.emit_struct(params_struct))
      buf.write_string("\n")
      standalone_generate_constructor(buf, params_struct)
      if standalone_has_validatable_fields(params_struct) {
        buf.write_string(validator_emitter.emit_struct_validator(params_struct))
        buf.write_string("\n")
      }
    }
  }

  // Generate SQL constants and functions
  for query in queries {
    standalone_generate_query_function(buf, query)
  }
  buf.to_string()
}

///|
/// Generate MoonBit code from SQL file content
pub fn generate_from_sql(sql_content : String) -> String {
  let queries = parse_sql_queries(sql_content)
  generate_from_queries(queries)
}

// Internal helper functions

///|
fn standalone_query_to_row_struct(query : QueryDef) -> @ir.Struct {
  let struct_name = query.name + "Row"
  let mut s = @ir.Struct::new(struct_name).with_derives(["Show", "Eq"])
  for ret in query.returns {
    let field = @ir.Field::new(
      to_snake_case(ret.0),
      standalone_sql_type_to_ir(ret.1),
    )
    s = s.with_field(field)
  }
  s
}

///|
fn standalone_query_to_params_struct(query : QueryDef) -> @ir.Struct {
  let struct_name = query.name + "Params"
  let mut s = @ir.Struct::new(struct_name).with_derives(["Show", "Eq"])
  for param in query.params {
    let ty = standalone_sql_type_to_ir(param.1)
    let mut field = @ir.Field::new(to_snake_case(param.0), ty)
    if standalone_is_string_sql_type(param.1) {
      field = field.as_required()
    }
    s = s.with_field(field)
  }
  s
}

///|
fn standalone_sql_type_to_ir(sql_type : String) -> @ir.Type {
  match sql_type.to_upper() {
    "INTEGER" | "INT" | "INT4" | "INT8" | "BIGINT" | "SMALLINT" =>
      @ir.Type::int64()
    "REAL" | "FLOAT" | "DOUBLE" | "NUMERIC" | "DECIMAL" => @ir.Type::double()
    "TEXT" | "VARCHAR" | "CHAR" => @ir.Type::string()
    "BLOB" | "BYTEA" => @ir.Type::bytes()
    "BOOLEAN" | "BOOL" => @ir.Type::bool()
    _ => @ir.Type::string()
  }
}

///|
fn standalone_is_string_sql_type(sql_type : String) -> Bool {
  match sql_type.to_upper() {
    "TEXT" | "VARCHAR" | "CHAR" => true
    _ => false
  }
}

///|
fn standalone_has_validatable_fields(s : @ir.Struct) -> Bool {
  for field in s.fields {
    if not(field.constraints.is_empty()) {
      return true
    }
  }
  false
}

///|
fn standalone_generate_constructor(buf : StringBuilder, s : @ir.Struct) -> Unit {
  buf.write_string("///|\npub fn ")
  buf.write_string(s.name)
  buf.write_string("::new(")
  for i, field in s.fields {
    if i > 0 {
      buf.write_string(", ")
    }
    buf.write_string(field.name)
    buf.write_string(" : ")
    standalone_emit_ir_type(buf, field.ty)
  }
  buf.write_string(") -> ")
  buf.write_string(s.name)
  buf.write_string(" {\n  { ")
  for i, field in s.fields {
    if i > 0 {
      buf.write_string(", ")
    }
    buf.write_string(field.name)
  }
  buf.write_string(" }\n}\n\n")
}

///|
fn standalone_emit_ir_type(buf : StringBuilder, ty : @ir.Type) -> Unit {
  match ty {
    @ir.Type::Primitive(name) => buf.write_string(name)
    @ir.Type::Optional(inner) => {
      standalone_emit_ir_type(buf, inner)
      buf.write_string("?")
    }
    @ir.Type::Array(inner) => {
      buf.write_string("Array[")
      standalone_emit_ir_type(buf, inner)
      buf.write_string("]")
    }
    @ir.Type::Named(name, _) => buf.write_string(name)
    _ => buf.write_string("Unit")
  }
}

///|
fn standalone_generate_query_function(
  buf : StringBuilder,
  query : QueryDef,
) -> Unit {
  let func_name = to_snake_case(query.name)
  let row_type = query.name + "Row"
  let params_type = query.name + "Params"
  let sql_const = func_name + "_sql"
  buf.write_string("///|\npub let ")
  buf.write_string(sql_const)
  buf.write_string(" : String = \"")
  buf.write_string(standalone_escape_string(query.sql))
  buf.write_string("\"\n\n")
  let return_type = match query.cmd {
    ":one" => row_type + "?"
    ":many" => "Array[" + row_type + "]"
    _ => "Unit"
  }
  buf.write_string("///| ")
  buf.write_string(query.name)
  buf.write_string("\npub fn ")
  buf.write_string(func_name)
  buf.write_string("(db : @sqlite.Sqlite3")
  if query.params.length() > 0 {
    buf.write_string(", params : ")
    buf.write_string(params_type)
  }
  buf.write_string(") -> ")
  buf.write_string(return_type)
  buf.write_string(" {\n")
  buf.write_string("  let stmt = @sqlite.sqlite_prepare(db, cstring(")
  buf.write_string(sql_const)
  buf.write_string("))\n")
  for i, param in query.params {
    let idx = (i + 1).to_string()
    let param_name = "params." + to_snake_case(param.0)
    buf.write_string("  ")
    buf.write_string(standalone_param_to_bind_call(param.1, idx, param_name))
    buf.write_string(" |> ignore\n")
  }
  match query.cmd {
    ":one" => {
      buf.write_string(
        "  if @sqlite.sqlite_step(stmt) == @sqlite.SQLITE_ROW {\n",
      )
      buf.write_string("    let row : ")
      buf.write_string(row_type)
      buf.write_string(" = {\n")
      for i, ret in query.returns {
        buf.write_string("      ")
        buf.write_string(to_snake_case(ret.0))
        buf.write_string(": ")
        buf.write_string(standalone_column_to_moonbit(ret.1, i))
        buf.write_string(",\n")
      }
      buf.write_string("    }\n")
      buf.write_string("    @sqlite.sqlite_finalize(stmt)\n")
      buf.write_string("    Some(row)\n")
      buf.write_string("  } else {\n")
      buf.write_string("    @sqlite.sqlite_finalize(stmt)\n")
      buf.write_string("    None\n")
      buf.write_string("  }\n")
    }
    ":many" => {
      buf.write_string("  let results : Array[")
      buf.write_string(row_type)
      buf.write_string("] = []\n")
      buf.write_string(
        "  while @sqlite.sqlite_step(stmt) == @sqlite.SQLITE_ROW {\n",
      )
      buf.write_string("    let row : ")
      buf.write_string(row_type)
      buf.write_string(" = {\n")
      for i, ret in query.returns {
        buf.write_string("      ")
        buf.write_string(to_snake_case(ret.0))
        buf.write_string(": ")
        buf.write_string(standalone_column_to_moonbit(ret.1, i))
        buf.write_string(",\n")
      }
      buf.write_string("    }\n")
      buf.write_string("    results.push(row)\n")
      buf.write_string("  }\n")
      buf.write_string("  @sqlite.sqlite_finalize(stmt)\n")
      buf.write_string("  results\n")
    }
    _ => {
      buf.write_string("  @sqlite.sqlite_step(stmt) |> ignore\n")
      buf.write_string("  @sqlite.sqlite_finalize(stmt)\n")
    }
  }
  buf.write_string("}\n\n")
}

///|
fn standalone_param_to_bind_call(
  sql_type : String,
  idx : String,
  expr : String,
) -> String {
  match sql_type.to_upper() {
    "INTEGER" | "INT" | "INT4" | "INT8" | "BIGINT" =>
      "@sqlite.sqlite_bind_int64(stmt, " + idx + ", " + expr + ")"
    "SMALLINT" =>
      "@sqlite.sqlite_bind_int(stmt, " + idx + ", " + expr + ".to_int())"
    "REAL" | "FLOAT" | "DOUBLE" =>
      "@sqlite.sqlite_bind_double(stmt, " + idx + ", " + expr + ")"
    "TEXT" | "VARCHAR" | "CHAR" =>
      "@sqlite.sqlite_bind_text(stmt, " + idx + ", cstring(" + expr + "))"
    "BLOB" | "BYTEA" =>
      "@sqlite.sqlite_bind_blob(stmt, " + idx + ", " + expr + ")"
    "BOOLEAN" | "BOOL" =>
      "@sqlite.sqlite_bind_int(stmt, " +
      idx +
      ", if " +
      expr +
      " { 1 } else { 0 })"
    _ => "@sqlite.sqlite_bind_text(stmt, " + idx + ", cstring(" + expr + "))"
  }
}

///|
fn standalone_column_to_moonbit(sql_type : String, idx : Int) -> String {
  let idx_str = idx.to_string()
  match sql_type.to_upper() {
    "INTEGER" | "INT" | "INT4" | "INT8" | "BIGINT" | "SMALLINT" =>
      "@sqlite.sqlite_column_int64(stmt, " + idx_str + ")"
    "REAL" | "FLOAT" | "DOUBLE" =>
      "@sqlite.sqlite_column_double(stmt, " + idx_str + ")"
    "TEXT" | "VARCHAR" | "CHAR" =>
      "bytes_to_string(@sqlite.sqlite_column_text(stmt, " + idx_str + "))"
    "BLOB" | "BYTEA" => "@sqlite.sqlite_column_blob(stmt, " + idx_str + ")"
    "BOOLEAN" | "BOOL" =>
      "@sqlite.sqlite_column_int(stmt, " + idx_str + ") != 0"
    _ => "bytes_to_string(@sqlite.sqlite_column_text(stmt, " + idx_str + "))"
  }
}

///|
fn standalone_escape_string(s : String) -> String {
  let buf = StringBuilder::new()
  for c in s {
    match c {
      '"' => buf.write_string("\\\"")
      '\\' => buf.write_string("\\\\")
      '\n' => buf.write_string(" ")
      '\r' => ()
      '\t' => buf.write_string(" ")
      _ => buf.write_char(c)
    }
  }
  buf.to_string()
}

// String utilities

///|
fn standalone_substr(s : String, start : Int) -> String {
  let buf = StringBuilder::new()
  let chars = s.to_array()
  for i = start; i < chars.length(); i = i + 1 {
    buf.write_char(chars[i])
  }
  buf.to_string()
}

///|
fn standalone_split_lines(s : String) -> Array[String] {
  let lines : Array[String] = []
  let buf = StringBuilder::new()
  for c in s {
    if c == '\n' {
      lines.push(buf.to_string())
      buf.reset()
    } else if c != '\r' {
      buf.write_char(c)
    }
  }
  if buf.to_string().length() > 0 {
    lines.push(buf.to_string())
  }
  lines
}

///|
fn standalone_split_whitespace(s : String) -> Array[String] {
  let parts : Array[String] = []
  let buf = StringBuilder::new()
  for c in s {
    if c == ' ' || c == '\t' {
      if buf.to_string().length() > 0 {
        parts.push(buf.to_string())
        buf.reset()
      }
    } else {
      buf.write_char(c)
    }
  }
  if buf.to_string().length() > 0 {
    parts.push(buf.to_string())
  }
  parts
}

///|
fn standalone_split_by_comma(s : String) -> Array[String] {
  let parts : Array[String] = []
  let buf = StringBuilder::new()
  for c in s {
    if c == ',' {
      parts.push(buf.to_string())
      buf.reset()
    } else {
      buf.write_char(c)
    }
  }
  if buf.to_string().length() > 0 {
    parts.push(buf.to_string())
  }
  parts
}

///|
fn standalone_join_lines(lines : Array[String], sep : String) -> String {
  let buf = StringBuilder::new()
  for i, line in lines {
    if i > 0 {
      buf.write_string(sep)
    }
    buf.write_string(line)
  }
  buf.to_string()
}
