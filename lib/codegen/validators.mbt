// Validator generation for Params structs

///|
pub fn generate_validators(request : @plugin.GenerateRequest) -> String {
  let buf = StringBuilder::new()
  buf.write_string("// Generated by sqlc-gen-moonbit\n")
  buf.write_string("// Validation functions for Params structs\n\n")

  // Generate validators for each Params struct
  for query in request.queries {
    if query.params.length() > 0 {
      let struct_name = to_pascal_case(query.name) + "Params"
      generate_validator_function(buf, struct_name, query.params)
    }
  }
  buf.to_string()
}

///|
fn has_string_validations(params : Array[@plugin.Parameter]) -> Bool {
  for param in params {
    let col = param.column
    let type_name = col.type_.name.to_upper()
    match type_name {
      "TEXT" | "VARCHAR" | "CHAR" | "CHARACTER" | "CLOB" =>
        if col.not_null || col.length > 0 {
          return true
        }
      _ => ()
    }
  }
  false
}

///|
fn generate_validator_function(
  buf : StringBuilder,
  struct_name : String,
  params : Array[@plugin.Parameter],
) -> Unit {
  let has_validations = has_string_validations(params)
  buf.write_string("///| Validate ")
  buf.write_string(struct_name)
  buf.write_string("\n")
  buf.write_string("pub fn ")
  buf.write_string(struct_name)
  if has_validations {
    buf.write_string("::validate(self : ")
  } else {
    buf.write_string("::validate(_self : ")
  }
  buf.write_string(struct_name)
  buf.write_string(") -> Result[Unit, String] {\n")
  for param in params {
    let col = param.column
    let param_name = if col.name.length() > 0 {
      to_snake_case(col.name)
    } else {
      "p" + param.number.to_string()
    }
    let type_name = col.type_.name.to_upper()

    // Generate validation based on constraints
    if col.not_null {
      // For NOT NULL String types, check for empty string
      match type_name {
        "TEXT" | "VARCHAR" | "CHAR" | "CHARACTER" | "CLOB" => {
          buf.write_string("  if self.")
          buf.write_string(param_name)
          buf.write_string(".length() == 0 {\n")
          buf.write_string("    return Err(\"")
          buf.write_string(param_name)
          buf.write_string(" is required\")\n")
          buf.write_string("  }\n")
        }
        _ => ()
      }
    }

    // Length validation for VARCHAR(n)
    if col.length > 0 {
      match type_name {
        "TEXT" | "VARCHAR" | "CHAR" | "CHARACTER" | "CLOB" => {
          let field_expr = if col.not_null {
            "self." + param_name
          } else {
            // For nullable, wrap in match
            ""
          }
          if col.not_null {
            buf.write_string("  if ")
            buf.write_string(field_expr)
            buf.write_string(".length() > ")
            buf.write_string(col.length.to_string())
            buf.write_string(" {\n")
            buf.write_string("    return Err(\"")
            buf.write_string(param_name)
            buf.write_string(" must be at most ")
            buf.write_string(col.length.to_string())
            buf.write_string(" characters\")\n")
            buf.write_string("  }\n")
          } else {
            buf.write_string("  match self.")
            buf.write_string(param_name)
            buf.write_string(" {\n")
            buf.write_string("    Some(v) => if v.length() > ")
            buf.write_string(col.length.to_string())
            buf.write_string(" {\n")
            buf.write_string("      return Err(\"")
            buf.write_string(param_name)
            buf.write_string(" must be at most ")
            buf.write_string(col.length.to_string())
            buf.write_string(" characters\")\n")
            buf.write_string("    }\n")
            buf.write_string("    None => ()\n")
            buf.write_string("  }\n")
          }
        }
        _ => ()
      }
    }

    // Unsigned validation for numeric types
    if col.unsigned {
      match type_name {
        "INTEGER" | "INT" | "INT4" | "INT8" | "BIGINT" | "SMALLINT" =>
          if col.not_null {
            buf.write_string("  if self.")
            buf.write_string(param_name)
            buf.write_string(" < 0L {\n")
            buf.write_string("    return Err(\"")
            buf.write_string(param_name)
            buf.write_string(" must be non-negative\")\n")
            buf.write_string("  }\n")
          } else {
            buf.write_string("  match self.")
            buf.write_string(param_name)
            buf.write_string(" {\n")
            buf.write_string("    Some(v) => if v < 0L {\n")
            buf.write_string("      return Err(\"")
            buf.write_string(param_name)
            buf.write_string(" must be non-negative\")\n")
            buf.write_string("    }\n")
            buf.write_string("    None => ()\n")
            buf.write_string("  }\n")
          }
        _ => ()
      }
    }
  }
  buf.write_string("  Ok(())\n")
  buf.write_string("}\n\n")
}
