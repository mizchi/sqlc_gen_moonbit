// Generated by sqlc-gen-moonbit (backend: postgres)
// Requires: mattn/postgres

///| Escape single quotes for SQL
fn sql_escape(s : String) -> String {
  s.replace(old="'", new="''")
}

// Query functions
///| GetUserById
///  SELECT id, name, email, age, balance, is_active, bio, created_at FROM users WHERE id = $1
pub fn get_user_by_id(conn : @postgres.Connection, params : GetUserByIdParams) -> Result[GetUserByIdRow?, @postgres.PgError] {
  let sql = get_user_by_id_sql
  let sql = sql.replace(old="$1", new=params.id.to_string())
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      if rows.length() == 0 {
        Ok(None)
      } else {
        let row = rows[0]
        Ok(Some({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          name: row[1],
          email: row[2],
          age: (if row[3].length() == 0 { None } else { Some((try { @strconv.parse_int(row[3]) } catch { _ => 0 })) }),
          balance: (if row[4].length() == 0 { None } else { Some((try { @strconv.parse_double(row[4]) } catch { _ => 0.0 })) }),
          is_active: (row[5] == "t" || row[5] == "true"),
          bio: (if row[6].length() == 0 { None } else { Some(row[6]) }),
          created_at: row[7],
        }))
      }
    }
  }
}

///| GetUserByEmail
/// SELECT id, name, email, age, balance, is_active, bio, created_at FROM users WHERE email = $1
pub fn get_user_by_email(conn : @postgres.Connection, params : GetUserByEmailParams) -> Result[GetUserByEmailRow?, @postgres.PgError] {
  let sql = get_user_by_email_sql
  let sql = sql.replace(old="$1", new="'" + sql_escape(params.email.to_string()) + "'")
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      if rows.length() == 0 {
        Ok(None)
      } else {
        let row = rows[0]
        Ok(Some({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          name: row[1],
          email: row[2],
          age: (if row[3].length() == 0 { None } else { Some((try { @strconv.parse_int(row[3]) } catch { _ => 0 })) }),
          balance: (if row[4].length() == 0 { None } else { Some((try { @strconv.parse_double(row[4]) } catch { _ => 0.0 })) }),
          is_active: (row[5] == "t" || row[5] == "true"),
          bio: (if row[6].length() == 0 { None } else { Some(row[6]) }),
          created_at: row[7],
        }))
      }
    }
  }
}

///| ListUsers
/// SELECT id, name, email, age, balance, is_active, bio, created_at FROM users ORDER BY name
pub fn list_users(conn : @postgres.Connection) -> Result[Array[ListUsersRow], @postgres.PgError] {
  let result = conn.query(list_users_sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      let results : Array[ListUsersRow] = []
      for row in rows {
        results.push({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          name: row[1],
          email: row[2],
          age: (if row[3].length() == 0 { None } else { Some((try { @strconv.parse_int(row[3]) } catch { _ => 0 })) }),
          balance: (if row[4].length() == 0 { None } else { Some((try { @strconv.parse_double(row[4]) } catch { _ => 0.0 })) }),
          is_active: (row[5] == "t" || row[5] == "true"),
          bio: (if row[6].length() == 0 { None } else { Some(row[6]) }),
          created_at: row[7],
        })
      }
      Ok(results)
    }
  }
}

///| ListActiveUsers
/// SELECT id, name, email, age, balance, is_active, bio, created_at FROM users WHERE is_active = TRUE ORDER BY name
pub fn list_active_users(conn : @postgres.Connection) -> Result[Array[ListActiveUsersRow], @postgres.PgError] {
  let result = conn.query(list_active_users_sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      let results : Array[ListActiveUsersRow] = []
      for row in rows {
        results.push({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          name: row[1],
          email: row[2],
          age: (if row[3].length() == 0 { None } else { Some((try { @strconv.parse_int(row[3]) } catch { _ => 0 })) }),
          balance: (if row[4].length() == 0 { None } else { Some((try { @strconv.parse_double(row[4]) } catch { _ => 0.0 })) }),
          is_active: (row[5] == "t" || row[5] == "true"),
          bio: (if row[6].length() == 0 { None } else { Some(row[6]) }),
          created_at: row[7],
        })
      }
      Ok(results)
    }
  }
}

///| CreateUser
/// INSERT INTO users (name, email, age, balance, is_active, bio) VALUES ($1, $2, $3, $4, $5, $6)
pub fn create_user(conn : @postgres.Connection, params : CreateUserParams) -> Result[Unit, @postgres.PgError] {
  let sql = create_user_sql
  let sql = sql.replace(old="$1", new="'" + sql_escape(params.name.to_string()) + "'")
  let sql = sql.replace(old="$2", new="'" + sql_escape(params.email.to_string()) + "'")
  let sql = sql.replace(old="$3", new=(match params.age { Some(v) => "'" + sql_escape(v.to_string()) + "'"; None => "NULL" }))
  let sql = sql.replace(old="$4", new=(match params.balance { Some(v) => "'" + sql_escape(v.to_string()) + "'"; None => "NULL" }))
  let sql = sql.replace(old="$5", new="'" + sql_escape(params.is_active.to_string()) + "'")
  let sql = sql.replace(old="$6", new=(match params.bio { Some(v) => "'" + sql_escape(v) + "'"; None => "NULL" }))
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      qr.free()
      Ok(())
    }
  }
}

///| CreateUserReturningId
/// INSERT INTO users (name, email, age, balance, is_active, bio) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id
pub fn create_user_returning_id(conn : @postgres.Connection, params : CreateUserReturningIdParams) -> Result[Int64, @postgres.PgError] {
  let sql = create_user_returning_id_sql
  let sql = sql.replace(old="$1", new="'" + sql_escape(params.name.to_string()) + "'")
  let sql = sql.replace(old="$2", new="'" + sql_escape(params.email.to_string()) + "'")
  let sql = sql.replace(old="$3", new=(match params.age { Some(v) => "'" + sql_escape(v.to_string()) + "'"; None => "NULL" }))
  let sql = sql.replace(old="$4", new=(match params.balance { Some(v) => "'" + sql_escape(v.to_string()) + "'"; None => "NULL" }))
  let sql = sql.replace(old="$5", new="'" + sql_escape(params.is_active.to_string()) + "'")
  let sql = sql.replace(old="$6", new=(match params.bio { Some(v) => "'" + sql_escape(v) + "'"; None => "NULL" }))
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      // For INSERT RETURNING, get the returned id from first row
      let rows = qr.rows()
      qr.free()
      if rows.length() > 0 && rows[0].length() > 0 {
        Ok(try { @strconv.parse_int64(rows[0][0]) } catch { _ => 0L })
      } else {
        Ok(0L)
      }
    }
  }
}

///| DeleteUserById
/// DELETE FROM users WHERE id = $1
pub fn delete_user_by_id(conn : @postgres.Connection, params : DeleteUserByIdParams) -> Result[Int, @postgres.PgError] {
  let sql = delete_user_by_id_sql
  let sql = sql.replace(old="$1", new=params.id.to_string())
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let count = qr.affected_rows()
      qr.free()
      Ok(count)
    }
  }
}

///| UpdateUserName
/// UPDATE users SET name = $2 WHERE id = $1
pub fn update_user_name(conn : @postgres.Connection, params : UpdateUserNameParams) -> Result[Int, @postgres.PgError] {
  let sql = update_user_name_sql
  let sql = sql.replace(old="$1", new=params.id.to_string())
  let sql = sql.replace(old="$2", new="'" + sql_escape(params.name.to_string()) + "'")
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let count = qr.affected_rows()
      qr.free()
      Ok(count)
    }
  }
}

///| UpdateUserBio
///  UPDATE users SET bio = $2 WHERE id = $1
pub fn update_user_bio(conn : @postgres.Connection, params : UpdateUserBioParams) -> Result[Int, @postgres.PgError] {
  let sql = update_user_bio_sql
  let sql = sql.replace(old="$1", new=params.id.to_string())
  let sql = sql.replace(old="$2", new=(match params.bio { Some(v) => "'" + sql_escape(v) + "'"; None => "NULL" }))
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let count = qr.affected_rows()
      qr.free()
      Ok(count)
    }
  }
}

///| GetUsersWithBio
/// SELECT id, name, email, age, balance, is_active, bio, created_at FROM users WHERE bio IS NOT NULL ORDER BY name
pub fn get_users_with_bio(conn : @postgres.Connection) -> Result[Array[GetUsersWithBioRow], @postgres.PgError] {
  let result = conn.query(get_users_with_bio_sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      let results : Array[GetUsersWithBioRow] = []
      for row in rows {
        results.push({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          name: row[1],
          email: row[2],
          age: (if row[3].length() == 0 { None } else { Some((try { @strconv.parse_int(row[3]) } catch { _ => 0 })) }),
          balance: (if row[4].length() == 0 { None } else { Some((try { @strconv.parse_double(row[4]) } catch { _ => 0.0 })) }),
          is_active: (row[5] == "t" || row[5] == "true"),
          bio: (if row[6].length() == 0 { None } else { Some(row[6]) }),
          created_at: row[7],
        })
      }
      Ok(results)
    }
  }
}

///| GetUsersWithoutBio
/// SELECT id, name, email, age, balance, is_active, bio, created_at FROM users WHERE bio IS NULL ORDER BY name
pub fn get_users_without_bio(conn : @postgres.Connection) -> Result[Array[GetUsersWithoutBioRow], @postgres.PgError] {
  let result = conn.query(get_users_without_bio_sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      let results : Array[GetUsersWithoutBioRow] = []
      for row in rows {
        results.push({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          name: row[1],
          email: row[2],
          age: (if row[3].length() == 0 { None } else { Some((try { @strconv.parse_int(row[3]) } catch { _ => 0 })) }),
          balance: (if row[4].length() == 0 { None } else { Some((try { @strconv.parse_double(row[4]) } catch { _ => 0.0 })) }),
          is_active: (row[5] == "t" || row[5] == "true"),
          bio: (if row[6].length() == 0 { None } else { Some(row[6]) }),
          created_at: row[7],
        })
      }
      Ok(results)
    }
  }
}

///| UpdateUserBalance
///  UPDATE users SET balance = $2 WHERE id = $1
pub fn update_user_balance(conn : @postgres.Connection, params : UpdateUserBalanceParams) -> Result[Int, @postgres.PgError] {
  let sql = update_user_balance_sql
  let sql = sql.replace(old="$1", new=params.id.to_string())
  let sql = sql.replace(old="$2", new=(match params.balance { Some(v) => "'" + sql_escape(v.to_string()) + "'"; None => "NULL" }))
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let count = qr.affected_rows()
      qr.free()
      Ok(count)
    }
  }
}

///| GetUsersWithPositiveBalance
/// SELECT id, name, email, age, balance, is_active, bio, created_at FROM users WHERE balance > 0.0 ORDER BY balance DESC
pub fn get_users_with_positive_balance(conn : @postgres.Connection) -> Result[Array[GetUsersWithPositiveBalanceRow], @postgres.PgError] {
  let result = conn.query(get_users_with_positive_balance_sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      let results : Array[GetUsersWithPositiveBalanceRow] = []
      for row in rows {
        results.push({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          name: row[1],
          email: row[2],
          age: (if row[3].length() == 0 { None } else { Some((try { @strconv.parse_int(row[3]) } catch { _ => 0 })) }),
          balance: (if row[4].length() == 0 { None } else { Some((try { @strconv.parse_double(row[4]) } catch { _ => 0.0 })) }),
          is_active: (row[5] == "t" || row[5] == "true"),
          bio: (if row[6].length() == 0 { None } else { Some(row[6]) }),
          created_at: row[7],
        })
      }
      Ok(results)
    }
  }
}

///| ActivateUser
///  UPDATE users SET is_active = TRUE WHERE id = $1
pub fn activate_user(conn : @postgres.Connection, params : ActivateUserParams) -> Result[Int, @postgres.PgError] {
  let sql = activate_user_sql
  let sql = sql.replace(old="$1", new=params.id.to_string())
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let count = qr.affected_rows()
      qr.free()
      Ok(count)
    }
  }
}

///| DeactivateUser
/// UPDATE users SET is_active = FALSE WHERE id = $1
pub fn deactivate_user(conn : @postgres.Connection, params : DeactivateUserParams) -> Result[Int, @postgres.PgError] {
  let sql = deactivate_user_sql
  let sql = sql.replace(old="$1", new=params.id.to_string())
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let count = qr.affected_rows()
      qr.free()
      Ok(count)
    }
  }
}

///| CountActiveUsers
/// SELECT COUNT(*) as count FROM users WHERE is_active = TRUE
pub fn count_active_users(conn : @postgres.Connection) -> Result[CountActiveUsersRow?, @postgres.PgError] {
  let result = conn.query(count_active_users_sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      if rows.length() == 0 {
        Ok(None)
      } else {
        let row = rows[0]
        Ok(Some({
          count: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
        }))
      }
    }
  }
}

///| SearchUsersByName
///  SELECT id, name, email, age, balance, is_active, bio, created_at FROM users WHERE name LIKE $1 ORDER BY name
pub fn search_users_by_name(conn : @postgres.Connection, params : SearchUsersByNameParams) -> Result[Array[SearchUsersByNameRow], @postgres.PgError] {
  let sql = search_users_by_name_sql
  let sql = sql.replace(old="$1", new="'" + sql_escape(params.name.to_string()) + "'")
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      let results : Array[SearchUsersByNameRow] = []
      for row in rows {
        results.push({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          name: row[1],
          email: row[2],
          age: (if row[3].length() == 0 { None } else { Some((try { @strconv.parse_int(row[3]) } catch { _ => 0 })) }),
          balance: (if row[4].length() == 0 { None } else { Some((try { @strconv.parse_double(row[4]) } catch { _ => 0.0 })) }),
          is_active: (row[5] == "t" || row[5] == "true"),
          bio: (if row[6].length() == 0 { None } else { Some(row[6]) }),
          created_at: row[7],
        })
      }
      Ok(results)
    }
  }
}

///| ListUsersWithLimit
/// SELECT id, name, email, age, balance, is_active, bio, created_at FROM users ORDER BY id LIMIT $1
pub fn list_users_with_limit(conn : @postgres.Connection, params : ListUsersWithLimitParams) -> Result[Array[ListUsersWithLimitRow], @postgres.PgError] {
  let sql = list_users_with_limit_sql
  let sql = sql.replace(old="$1", new=params.limit.to_string())
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      let results : Array[ListUsersWithLimitRow] = []
      for row in rows {
        results.push({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          name: row[1],
          email: row[2],
          age: (if row[3].length() == 0 { None } else { Some((try { @strconv.parse_int(row[3]) } catch { _ => 0 })) }),
          balance: (if row[4].length() == 0 { None } else { Some((try { @strconv.parse_double(row[4]) } catch { _ => 0.0 })) }),
          is_active: (row[5] == "t" || row[5] == "true"),
          bio: (if row[6].length() == 0 { None } else { Some(row[6]) }),
          created_at: row[7],
        })
      }
      Ok(results)
    }
  }
}

///| GetUserCount
/// SELECT COUNT(*) as count FROM users
pub fn get_user_count(conn : @postgres.Connection) -> Result[GetUserCountRow?, @postgres.PgError] {
  let result = conn.query(get_user_count_sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      if rows.length() == 0 {
        Ok(None)
      } else {
        let row = rows[0]
        Ok(Some({
          count: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
        }))
      }
    }
  }
}

///| CreatePost
///  INSERT INTO posts (author_id, title, content, is_published) VALUES ($1, $2, $3, $4)
pub fn create_post(conn : @postgres.Connection, params : CreatePostParams) -> Result[Unit, @postgres.PgError] {
  let sql = create_post_sql
  let sql = sql.replace(old="$1", new="'" + sql_escape(params.author_id.to_string()) + "'")
  let sql = sql.replace(old="$2", new="'" + sql_escape(params.title.to_string()) + "'")
  let sql = sql.replace(old="$3", new="'" + sql_escape(params.content) + "'")
  let sql = sql.replace(old="$4", new="'" + sql_escape(params.is_published.to_string()) + "'")
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      qr.free()
      Ok(())
    }
  }
}

///| CreatePostReturningId
/// INSERT INTO posts (author_id, title, content, is_published) VALUES ($1, $2, $3, $4) RETURNING id
pub fn create_post_returning_id(conn : @postgres.Connection, params : CreatePostReturningIdParams) -> Result[Int64, @postgres.PgError] {
  let sql = create_post_returning_id_sql
  let sql = sql.replace(old="$1", new="'" + sql_escape(params.author_id.to_string()) + "'")
  let sql = sql.replace(old="$2", new="'" + sql_escape(params.title.to_string()) + "'")
  let sql = sql.replace(old="$3", new="'" + sql_escape(params.content) + "'")
  let sql = sql.replace(old="$4", new="'" + sql_escape(params.is_published.to_string()) + "'")
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      // For INSERT RETURNING, get the returned id from first row
      let rows = qr.rows()
      qr.free()
      if rows.length() > 0 && rows[0].length() > 0 {
        Ok(try { @strconv.parse_int64(rows[0][0]) } catch { _ => 0L })
      } else {
        Ok(0L)
      }
    }
  }
}

///| GetPostById
/// SELECT id, author_id, title, content, view_count, is_published, published_at, created_at FROM posts WHERE id = $1
pub fn get_post_by_id(conn : @postgres.Connection, params : GetPostByIdParams) -> Result[GetPostByIdRow?, @postgres.PgError] {
  let sql = get_post_by_id_sql
  let sql = sql.replace(old="$1", new=params.id.to_string())
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      if rows.length() == 0 {
        Ok(None)
      } else {
        let row = rows[0]
        Ok(Some({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          author_id: (try { @strconv.parse_int(row[1]) } catch { _ => 0 }),
          title: row[2],
          content: row[3],
          view_count: (try { @strconv.parse_int(row[4]) } catch { _ => 0 }),
          is_published: (row[5] == "t" || row[5] == "true"),
          published_at: (if row[6].length() == 0 { None } else { Some(row[6]) }),
          created_at: row[7],
        }))
      }
    }
  }
}

///| ListPostsByAuthor
/// SELECT id, author_id, title, content, view_count, is_published, published_at, created_at FROM posts WHERE author_id = $1 ORDER BY created_at DESC
pub fn list_posts_by_author(conn : @postgres.Connection, params : ListPostsByAuthorParams) -> Result[Array[ListPostsByAuthorRow], @postgres.PgError] {
  let sql = list_posts_by_author_sql
  let sql = sql.replace(old="$1", new="'" + sql_escape(params.author_id.to_string()) + "'")
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      let results : Array[ListPostsByAuthorRow] = []
      for row in rows {
        results.push({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          author_id: (try { @strconv.parse_int(row[1]) } catch { _ => 0 }),
          title: row[2],
          content: row[3],
          view_count: (try { @strconv.parse_int(row[4]) } catch { _ => 0 }),
          is_published: (row[5] == "t" || row[5] == "true"),
          published_at: (if row[6].length() == 0 { None } else { Some(row[6]) }),
          created_at: row[7],
        })
      }
      Ok(results)
    }
  }
}

///| PublishPost
/// UPDATE posts SET is_published = TRUE, published_at = CURRENT_TIMESTAMP WHERE id = $1
pub fn publish_post(conn : @postgres.Connection, params : PublishPostParams) -> Result[Int, @postgres.PgError] {
  let sql = publish_post_sql
  let sql = sql.replace(old="$1", new=params.id.to_string())
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let count = qr.affected_rows()
      qr.free()
      Ok(count)
    }
  }
}

///| DeletePost
/// DELETE FROM posts WHERE id = $1
pub fn delete_post(conn : @postgres.Connection, params : DeletePostParams) -> Result[Int, @postgres.PgError] {
  let sql = delete_post_sql
  let sql = sql.replace(old="$1", new=params.id.to_string())
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let count = qr.affected_rows()
      qr.free()
      Ok(count)
    }
  }
}

///| IncrementViewCount
/// UPDATE posts SET view_count = view_count + 1 WHERE id = $1
pub fn increment_view_count(conn : @postgres.Connection, params : IncrementViewCountParams) -> Result[Int, @postgres.PgError] {
  let sql = increment_view_count_sql
  let sql = sql.replace(old="$1", new=params.id.to_string())
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let count = qr.affected_rows()
      qr.free()
      Ok(count)
    }
  }
}

///| GetPostWithAuthor
///  SELECT   p.id, p.title, p.content, p.view_count, p.is_published,   p.published_at, p.created_at,   u.id as author_id, u.name as author_name, u.email as author_email FROM posts p INNER JOIN users u ON p.author_id = u.id WHERE p.id = $1
pub fn get_post_with_author(conn : @postgres.Connection, params : GetPostWithAuthorParams) -> Result[GetPostWithAuthorRow?, @postgres.PgError] {
  let sql = get_post_with_author_sql
  let sql = sql.replace(old="$1", new=params.id.to_string())
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      if rows.length() == 0 {
        Ok(None)
      } else {
        let row = rows[0]
        Ok(Some({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          title: row[1],
          content: row[2],
          view_count: (try { @strconv.parse_int(row[3]) } catch { _ => 0 }),
          is_published: (row[4] == "t" || row[4] == "true"),
          published_at: (if row[5].length() == 0 { None } else { Some(row[5]) }),
          created_at: row[6],
          author_id: (try { @strconv.parse_int64(row[7]) } catch { _ => 0L }),
          author_name: row[8],
          author_email: row[9],
        }))
      }
    }
  }
}

///| ListPostsWithAuthors
/// SELECT   p.id, p.title, p.view_count, p.is_published, p.created_at,   u.id as author_id, u.name as author_name FROM posts p INNER JOIN users u ON p.author_id = u.id ORDER BY p.created_at DESC
pub fn list_posts_with_authors(conn : @postgres.Connection) -> Result[Array[ListPostsWithAuthorsRow], @postgres.PgError] {
  let result = conn.query(list_posts_with_authors_sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      let results : Array[ListPostsWithAuthorsRow] = []
      for row in rows {
        results.push({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          title: row[1],
          view_count: (try { @strconv.parse_int(row[2]) } catch { _ => 0 }),
          is_published: (row[3] == "t" || row[3] == "true"),
          created_at: row[4],
          author_id: (try { @strconv.parse_int64(row[5]) } catch { _ => 0L }),
          author_name: row[6],
        })
      }
      Ok(results)
    }
  }
}

///| GetPostCountByAuthor
///  SELECT COUNT(*) as post_count FROM posts WHERE author_id = $1
pub fn get_post_count_by_author(conn : @postgres.Connection, params : GetPostCountByAuthorParams) -> Result[GetPostCountByAuthorRow?, @postgres.PgError] {
  let sql = get_post_count_by_author_sql
  let sql = sql.replace(old="$1", new="'" + sql_escape(params.author_id.to_string()) + "'")
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      if rows.length() == 0 {
        Ok(None)
      } else {
        let row = rows[0]
        Ok(Some({
          post_count: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
        }))
      }
    }
  }
}

///| GetAuthorStats
/// SELECT   COUNT(*) as post_count,   COALESCE(SUM(view_count), 0) as total_views FROM posts WHERE author_id = $1
pub fn get_author_stats(conn : @postgres.Connection, params : GetAuthorStatsParams) -> Result[GetAuthorStatsRow?, @postgres.PgError] {
  let sql = get_author_stats_sql
  let sql = sql.replace(old="$1", new="'" + sql_escape(params.author_id.to_string()) + "'")
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      if rows.length() == 0 {
        Ok(None)
      } else {
        let row = rows[0]
        Ok(Some({
          post_count: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          total_views: (if row[1].length() == 0 { None } else { Some(row[1]) }),
        }))
      }
    }
  }
}

///| CreateTag
///  INSERT INTO tags (name) VALUES ($1)
pub fn create_tag(conn : @postgres.Connection, params : CreateTagParams) -> Result[Unit, @postgres.PgError] {
  let sql = create_tag_sql
  let sql = sql.replace(old="$1", new="'" + sql_escape(params.name.to_string()) + "'")
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      qr.free()
      Ok(())
    }
  }
}

///| CreateTagReturningId
/// INSERT INTO tags (name) VALUES ($1) RETURNING id
pub fn create_tag_returning_id(conn : @postgres.Connection, params : CreateTagReturningIdParams) -> Result[Int64, @postgres.PgError] {
  let sql = create_tag_returning_id_sql
  let sql = sql.replace(old="$1", new="'" + sql_escape(params.name.to_string()) + "'")
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      // For INSERT RETURNING, get the returned id from first row
      let rows = qr.rows()
      qr.free()
      if rows.length() > 0 && rows[0].length() > 0 {
        Ok(try { @strconv.parse_int64(rows[0][0]) } catch { _ => 0L })
      } else {
        Ok(0L)
      }
    }
  }
}

///| GetTagByName
/// SELECT id, name FROM tags WHERE name = $1
pub fn get_tag_by_name(conn : @postgres.Connection, params : GetTagByNameParams) -> Result[GetTagByNameRow?, @postgres.PgError] {
  let sql = get_tag_by_name_sql
  let sql = sql.replace(old="$1", new="'" + sql_escape(params.name.to_string()) + "'")
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      if rows.length() == 0 {
        Ok(None)
      } else {
        let row = rows[0]
        Ok(Some({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          name: row[1],
        }))
      }
    }
  }
}

///| ListTags
/// SELECT id, name FROM tags ORDER BY name
pub fn list_tags(conn : @postgres.Connection) -> Result[Array[ListTagsRow], @postgres.PgError] {
  let result = conn.query(list_tags_sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      let results : Array[ListTagsRow] = []
      for row in rows {
        results.push({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          name: row[1],
        })
      }
      Ok(results)
    }
  }
}

///| DeleteTag
/// DELETE FROM tags WHERE id = $1
pub fn delete_tag(conn : @postgres.Connection, params : DeleteTagParams) -> Result[Int, @postgres.PgError] {
  let sql = delete_tag_sql
  let sql = sql.replace(old="$1", new=params.id.to_string())
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let count = qr.affected_rows()
      qr.free()
      Ok(count)
    }
  }
}

///| AddTagToPost
///  INSERT INTO post_tags (post_id, tag_id) VALUES ($1, $2)
pub fn add_tag_to_post(conn : @postgres.Connection, params : AddTagToPostParams) -> Result[Unit, @postgres.PgError] {
  let sql = add_tag_to_post_sql
  let sql = sql.replace(old="$1", new="'" + sql_escape(params.post_id.to_string()) + "'")
  let sql = sql.replace(old="$2", new="'" + sql_escape(params.tag_id.to_string()) + "'")
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      qr.free()
      Ok(())
    }
  }
}

///| RemoveTagFromPost
/// DELETE FROM post_tags WHERE post_id = $1 AND tag_id = $2
pub fn remove_tag_from_post(conn : @postgres.Connection, params : RemoveTagFromPostParams) -> Result[Int, @postgres.PgError] {
  let sql = remove_tag_from_post_sql
  let sql = sql.replace(old="$1", new="'" + sql_escape(params.post_id.to_string()) + "'")
  let sql = sql.replace(old="$2", new="'" + sql_escape(params.tag_id.to_string()) + "'")
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let count = qr.affected_rows()
      qr.free()
      Ok(count)
    }
  }
}

///| ListTagsForPost
/// SELECT t.id, t.name FROM tags t INNER JOIN post_tags pt ON t.id = pt.tag_id WHERE pt.post_id = $1 ORDER BY t.name
pub fn list_tags_for_post(conn : @postgres.Connection, params : ListTagsForPostParams) -> Result[Array[ListTagsForPostRow], @postgres.PgError] {
  let sql = list_tags_for_post_sql
  let sql = sql.replace(old="$1", new="'" + sql_escape(params.post_id.to_string()) + "'")
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      let results : Array[ListTagsForPostRow] = []
      for row in rows {
        results.push({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          name: row[1],
        })
      }
      Ok(results)
    }
  }
}

///| GetTagCountForPost
/// SELECT COUNT(*) as tag_count FROM post_tags WHERE post_id = $1
pub fn get_tag_count_for_post(conn : @postgres.Connection, params : GetTagCountForPostParams) -> Result[GetTagCountForPostRow?, @postgres.PgError] {
  let sql = get_tag_count_for_post_sql
  let sql = sql.replace(old="$1", new="'" + sql_escape(params.post_id.to_string()) + "'")
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      if rows.length() == 0 {
        Ok(None)
      } else {
        let row = rows[0]
        Ok(Some({
          tag_count: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
        }))
      }
    }
  }
}

///| ListUsersPaginated
///  SELECT id, name, email, age, balance, is_active, bio, created_at FROM users WHERE id > $1 ORDER BY id LIMIT $2
pub fn list_users_paginated(conn : @postgres.Connection, params : ListUsersPaginatedParams) -> Result[Array[ListUsersPaginatedRow], @postgres.PgError] {
  let sql = list_users_paginated_sql
  let sql = sql.replace(old="$1", new=params.id.to_string())
  let sql = sql.replace(old="$2", new=params.limit.to_string())
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      let results : Array[ListUsersPaginatedRow] = []
      for row in rows {
        results.push({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          name: row[1],
          email: row[2],
          age: (if row[3].length() == 0 { None } else { Some((try { @strconv.parse_int(row[3]) } catch { _ => 0 })) }),
          balance: (if row[4].length() == 0 { None } else { Some((try { @strconv.parse_double(row[4]) } catch { _ => 0.0 })) }),
          is_active: (row[5] == "t" || row[5] == "true"),
          bio: (if row[6].length() == 0 { None } else { Some(row[6]) }),
          created_at: row[7],
        })
      }
      Ok(results)
    }
  }
}

///| ListPostsByAuthorPaginated
/// SELECT id, author_id, title, content, view_count, is_published, published_at, created_at FROM posts WHERE author_id = $1 AND id > $2 ORDER BY id LIMIT $3
pub fn list_posts_by_author_paginated(conn : @postgres.Connection, params : ListPostsByAuthorPaginatedParams) -> Result[Array[ListPostsByAuthorPaginatedRow], @postgres.PgError] {
  let sql = list_posts_by_author_paginated_sql
  let sql = sql.replace(old="$1", new="'" + sql_escape(params.author_id.to_string()) + "'")
  let sql = sql.replace(old="$2", new=params.id.to_string())
  let sql = sql.replace(old="$3", new=params.limit.to_string())
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      let results : Array[ListPostsByAuthorPaginatedRow] = []
      for row in rows {
        results.push({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          author_id: (try { @strconv.parse_int(row[1]) } catch { _ => 0 }),
          title: row[2],
          content: row[3],
          view_count: (try { @strconv.parse_int(row[4]) } catch { _ => 0 }),
          is_published: (row[5] == "t" || row[5] == "true"),
          published_at: (if row[6].length() == 0 { None } else { Some(row[6]) }),
          created_at: row[7],
        })
      }
      Ok(results)
    }
  }
}

///| ListPostsWithAuthorsPaginated
/// SELECT   p.id, p.title, p.view_count, p.is_published, p.created_at,   u.id as author_id, u.name as author_name FROM posts p INNER JOIN users u ON p.author_id = u.id WHERE p.id > $1 ORDER BY p.id LIMIT $2
pub fn list_posts_with_authors_paginated(conn : @postgres.Connection, params : ListPostsWithAuthorsPaginatedParams) -> Result[Array[ListPostsWithAuthorsPaginatedRow], @postgres.PgError] {
  let sql = list_posts_with_authors_paginated_sql
  let sql = sql.replace(old="$1", new=params.id.to_string())
  let sql = sql.replace(old="$2", new=params.limit.to_string())
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      let results : Array[ListPostsWithAuthorsPaginatedRow] = []
      for row in rows {
        results.push({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          title: row[1],
          view_count: (try { @strconv.parse_int(row[2]) } catch { _ => 0 }),
          is_published: (row[3] == "t" || row[3] == "true"),
          created_at: row[4],
          author_id: (try { @strconv.parse_int64(row[5]) } catch { _ => 0L }),
          author_name: row[6],
        })
      }
      Ok(results)
    }
  }
}

///| ListPublishedPostsPaginated
/// SELECT id, author_id, title, content, view_count, is_published, published_at, created_at FROM posts WHERE is_published = TRUE AND id > $1 ORDER BY id LIMIT $2
pub fn list_published_posts_paginated(conn : @postgres.Connection, params : ListPublishedPostsPaginatedParams) -> Result[Array[ListPublishedPostsPaginatedRow], @postgres.PgError] {
  let sql = list_published_posts_paginated_sql
  let sql = sql.replace(old="$1", new=params.id.to_string())
  let sql = sql.replace(old="$2", new=params.limit.to_string())
  let result = conn.query(sql)
  match result {
    Err(e) => Err(e)
    Ok(qr) => {
      let rows = qr.rows()
      qr.free()
      let results : Array[ListPublishedPostsPaginatedRow] = []
      for row in rows {
        results.push({
          id: (try { @strconv.parse_int64(row[0]) } catch { _ => 0L }),
          author_id: (try { @strconv.parse_int(row[1]) } catch { _ => 0 }),
          title: row[2],
          content: row[3],
          view_count: (try { @strconv.parse_int(row[4]) } catch { _ => 0 }),
          is_published: (row[5] == "t" || row[5] == "true"),
          published_at: (if row[6].length() == 0 { None } else { Some(row[6]) }),
          created_at: row[7],
        })
      }
      Ok(results)
    }
  }
}

