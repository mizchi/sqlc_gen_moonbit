// Generated by sqlc-gen-moonbit (backend: sqlite_js)
// Requires: mizchi/sqlite (JS target)

///|
fn bytes_to_string(b : Bytes) -> String {
  let decoder = @encoding.decoder(@encoding.UTF8)
  decoder.decode_lossy(b[0:b.length()])
}

// Query functions
///| GetUserById
///  SELECT id, name, email, age, balance, is_active, bio, created_at FROM users WHERE id = ?
pub fn get_user_by_id(db : @sqlite.Database, params : GetUserByIdParams) -> GetUserByIdRow? raise SqlError {
  let stmt = match db.prepare(get_user_by_id_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.id)) |> ignore
  if stmt.step() {
    let row : GetUserByIdRow = {
      id: stmt.column_int(0),
      name: bytes_to_string(stmt.column_text(1)),
      email: bytes_to_string(stmt.column_text(2)),
      age: (match stmt.column(3) { @sqlite.Null => None; _ => Some(stmt.column_int(3)) }),
      balance: (match stmt.column(4) { @sqlite.Null => None; _ => Some((match stmt.column(4) { @sqlite.Double(v) => v; @sqlite.Int(v) => v.to_double(); _ => 0.0 })) }),
      is_active: stmt.column_int(5),
      bio: (match stmt.column(6) { @sqlite.Null => None; _ => Some(bytes_to_string(stmt.column_text(6))) }),
      created_at: bytes_to_string(stmt.column_text(7)),
    }
    stmt.finalize()
    Some(row)
  } else {
    stmt.finalize()
    None
  }
}

///| GetUserByEmail
/// SELECT id, name, email, age, balance, is_active, bio, created_at FROM users WHERE email = ?
pub fn get_user_by_email(db : @sqlite.Database, params : GetUserByEmailParams) -> GetUserByEmailRow? raise SqlError {
  let stmt = match db.prepare(get_user_by_email_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Text(@encoding.encode(@encoding.UTF8, params.email))) |> ignore
  if stmt.step() {
    let row : GetUserByEmailRow = {
      id: stmt.column_int(0),
      name: bytes_to_string(stmt.column_text(1)),
      email: bytes_to_string(stmt.column_text(2)),
      age: (match stmt.column(3) { @sqlite.Null => None; _ => Some(stmt.column_int(3)) }),
      balance: (match stmt.column(4) { @sqlite.Null => None; _ => Some((match stmt.column(4) { @sqlite.Double(v) => v; @sqlite.Int(v) => v.to_double(); _ => 0.0 })) }),
      is_active: stmt.column_int(5),
      bio: (match stmt.column(6) { @sqlite.Null => None; _ => Some(bytes_to_string(stmt.column_text(6))) }),
      created_at: bytes_to_string(stmt.column_text(7)),
    }
    stmt.finalize()
    Some(row)
  } else {
    stmt.finalize()
    None
  }
}

///| ListUsers
/// SELECT id, name, email, age, balance, is_active, bio, created_at FROM users ORDER BY name
pub fn list_users(db : @sqlite.Database) -> Array[ListUsersRow] raise SqlError {
  let stmt = match db.prepare(list_users_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  let results : Array[ListUsersRow] = []
  while stmt.step() {
    let row : ListUsersRow = {
      id: stmt.column_int(0),
      name: bytes_to_string(stmt.column_text(1)),
      email: bytes_to_string(stmt.column_text(2)),
      age: (match stmt.column(3) { @sqlite.Null => None; _ => Some(stmt.column_int(3)) }),
      balance: (match stmt.column(4) { @sqlite.Null => None; _ => Some((match stmt.column(4) { @sqlite.Double(v) => v; @sqlite.Int(v) => v.to_double(); _ => 0.0 })) }),
      is_active: stmt.column_int(5),
      bio: (match stmt.column(6) { @sqlite.Null => None; _ => Some(bytes_to_string(stmt.column_text(6))) }),
      created_at: bytes_to_string(stmt.column_text(7)),
    }
    results.push(row)
  }
  stmt.finalize()
  results
}

///| ListActiveUsers
/// SELECT id, name, email, age, balance, is_active, bio, created_at FROM users WHERE is_active = 1 ORDER BY name
pub fn list_active_users(db : @sqlite.Database) -> Array[ListActiveUsersRow] raise SqlError {
  let stmt = match db.prepare(list_active_users_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  let results : Array[ListActiveUsersRow] = []
  while stmt.step() {
    let row : ListActiveUsersRow = {
      id: stmt.column_int(0),
      name: bytes_to_string(stmt.column_text(1)),
      email: bytes_to_string(stmt.column_text(2)),
      age: (match stmt.column(3) { @sqlite.Null => None; _ => Some(stmt.column_int(3)) }),
      balance: (match stmt.column(4) { @sqlite.Null => None; _ => Some((match stmt.column(4) { @sqlite.Double(v) => v; @sqlite.Int(v) => v.to_double(); _ => 0.0 })) }),
      is_active: stmt.column_int(5),
      bio: (match stmt.column(6) { @sqlite.Null => None; _ => Some(bytes_to_string(stmt.column_text(6))) }),
      created_at: bytes_to_string(stmt.column_text(7)),
    }
    results.push(row)
  }
  stmt.finalize()
  results
}

///| CreateUser
/// INSERT INTO users (name, email, age, balance, is_active, bio) VALUES (?, ?, ?, ?, ?, ?)
pub fn create_user(db : @sqlite.Database, params : CreateUserParams) -> Unit raise SqlError {
  let stmt = match db.prepare(create_user_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Text(@encoding.encode(@encoding.UTF8, params.name))) |> ignore
  stmt.bind(2, @sqlite.Text(@encoding.encode(@encoding.UTF8, params.email))) |> ignore
  stmt.bind(3, (match params.age { Some(v) => @sqlite.Int(v); None => @sqlite.Null })) |> ignore
  stmt.bind(4, (match params.balance { Some(v) => @sqlite.Double(v); None => @sqlite.Null })) |> ignore
  stmt.bind(5, @sqlite.Int(params.is_active)) |> ignore
  stmt.bind(6, (match params.bio { Some(v) => @sqlite.Text(@encoding.encode(@encoding.UTF8, v)); None => @sqlite.Null })) |> ignore
  stmt.execute() |> ignore
  stmt.finalize()
}

///| CreateUserReturningId
/// INSERT INTO users (name, email, age, balance, is_active, bio) VALUES (?, ?, ?, ?, ?, ?)
pub fn create_user_returning_id(db : @sqlite.Database, params : CreateUserReturningIdParams) -> Int64 raise SqlError {
  let stmt = match db.prepare(create_user_returning_id_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Text(@encoding.encode(@encoding.UTF8, params.name))) |> ignore
  stmt.bind(2, @sqlite.Text(@encoding.encode(@encoding.UTF8, params.email))) |> ignore
  stmt.bind(3, (match params.age { Some(v) => @sqlite.Int(v); None => @sqlite.Null })) |> ignore
  stmt.bind(4, (match params.balance { Some(v) => @sqlite.Double(v); None => @sqlite.Null })) |> ignore
  stmt.bind(5, @sqlite.Int(params.is_active)) |> ignore
  stmt.bind(6, (match params.bio { Some(v) => @sqlite.Text(@encoding.encode(@encoding.UTF8, v)); None => @sqlite.Null })) |> ignore
  stmt.execute() |> ignore
  stmt.finalize()
  db.last_insert_rowid()
}

///| DeleteUserById
/// DELETE FROM users WHERE id = ?
pub fn delete_user_by_id(db : @sqlite.Database, params : DeleteUserByIdParams) -> Int raise SqlError {
  let stmt = match db.prepare(delete_user_by_id_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.id)) |> ignore
  stmt.execute() |> ignore
  stmt.finalize()
  db.changes()
}

///| UpdateUserName
/// UPDATE users SET name = ? WHERE id = ?
pub fn update_user_name(db : @sqlite.Database, params : UpdateUserNameParams) -> Int raise SqlError {
  let stmt = match db.prepare(update_user_name_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Text(@encoding.encode(@encoding.UTF8, params.name))) |> ignore
  stmt.bind(2, @sqlite.Int(params.id)) |> ignore
  stmt.execute() |> ignore
  stmt.finalize()
  db.changes()
}

///| UpdateUserBio
///  UPDATE users SET bio = ? WHERE id = ?
pub fn update_user_bio(db : @sqlite.Database, params : UpdateUserBioParams) -> Int raise SqlError {
  let stmt = match db.prepare(update_user_bio_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, (match params.bio { Some(v) => @sqlite.Text(@encoding.encode(@encoding.UTF8, v)); None => @sqlite.Null })) |> ignore
  stmt.bind(2, @sqlite.Int(params.id)) |> ignore
  stmt.execute() |> ignore
  stmt.finalize()
  db.changes()
}

///| GetUsersWithBio
/// SELECT id, name, email, age, balance, is_active, bio, created_at FROM users WHERE bio IS NOT NULL ORDER BY name
pub fn get_users_with_bio(db : @sqlite.Database) -> Array[GetUsersWithBioRow] raise SqlError {
  let stmt = match db.prepare(get_users_with_bio_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  let results : Array[GetUsersWithBioRow] = []
  while stmt.step() {
    let row : GetUsersWithBioRow = {
      id: stmt.column_int(0),
      name: bytes_to_string(stmt.column_text(1)),
      email: bytes_to_string(stmt.column_text(2)),
      age: (match stmt.column(3) { @sqlite.Null => None; _ => Some(stmt.column_int(3)) }),
      balance: (match stmt.column(4) { @sqlite.Null => None; _ => Some((match stmt.column(4) { @sqlite.Double(v) => v; @sqlite.Int(v) => v.to_double(); _ => 0.0 })) }),
      is_active: stmt.column_int(5),
      bio: (match stmt.column(6) { @sqlite.Null => None; _ => Some(bytes_to_string(stmt.column_text(6))) }),
      created_at: bytes_to_string(stmt.column_text(7)),
    }
    results.push(row)
  }
  stmt.finalize()
  results
}

///| GetUsersWithoutBio
/// SELECT id, name, email, age, balance, is_active, bio, created_at FROM users WHERE bio IS NULL ORDER BY name
pub fn get_users_without_bio(db : @sqlite.Database) -> Array[GetUsersWithoutBioRow] raise SqlError {
  let stmt = match db.prepare(get_users_without_bio_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  let results : Array[GetUsersWithoutBioRow] = []
  while stmt.step() {
    let row : GetUsersWithoutBioRow = {
      id: stmt.column_int(0),
      name: bytes_to_string(stmt.column_text(1)),
      email: bytes_to_string(stmt.column_text(2)),
      age: (match stmt.column(3) { @sqlite.Null => None; _ => Some(stmt.column_int(3)) }),
      balance: (match stmt.column(4) { @sqlite.Null => None; _ => Some((match stmt.column(4) { @sqlite.Double(v) => v; @sqlite.Int(v) => v.to_double(); _ => 0.0 })) }),
      is_active: stmt.column_int(5),
      bio: (match stmt.column(6) { @sqlite.Null => None; _ => Some(bytes_to_string(stmt.column_text(6))) }),
      created_at: bytes_to_string(stmt.column_text(7)),
    }
    results.push(row)
  }
  stmt.finalize()
  results
}

///| UpdateUserBalance
///  UPDATE users SET balance = ? WHERE id = ?
pub fn update_user_balance(db : @sqlite.Database, params : UpdateUserBalanceParams) -> Int raise SqlError {
  let stmt = match db.prepare(update_user_balance_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, (match params.balance { Some(v) => @sqlite.Double(v); None => @sqlite.Null })) |> ignore
  stmt.bind(2, @sqlite.Int(params.id)) |> ignore
  stmt.execute() |> ignore
  stmt.finalize()
  db.changes()
}

///| GetUsersWithPositiveBalance
/// SELECT id, name, email, age, balance, is_active, bio, created_at FROM users WHERE balance > 0.0 ORDER BY balance DESC
pub fn get_users_with_positive_balance(db : @sqlite.Database) -> Array[GetUsersWithPositiveBalanceRow] raise SqlError {
  let stmt = match db.prepare(get_users_with_positive_balance_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  let results : Array[GetUsersWithPositiveBalanceRow] = []
  while stmt.step() {
    let row : GetUsersWithPositiveBalanceRow = {
      id: stmt.column_int(0),
      name: bytes_to_string(stmt.column_text(1)),
      email: bytes_to_string(stmt.column_text(2)),
      age: (match stmt.column(3) { @sqlite.Null => None; _ => Some(stmt.column_int(3)) }),
      balance: (match stmt.column(4) { @sqlite.Null => None; _ => Some((match stmt.column(4) { @sqlite.Double(v) => v; @sqlite.Int(v) => v.to_double(); _ => 0.0 })) }),
      is_active: stmt.column_int(5),
      bio: (match stmt.column(6) { @sqlite.Null => None; _ => Some(bytes_to_string(stmt.column_text(6))) }),
      created_at: bytes_to_string(stmt.column_text(7)),
    }
    results.push(row)
  }
  stmt.finalize()
  results
}

///| ActivateUser
///  UPDATE users SET is_active = 1 WHERE id = ?
pub fn activate_user(db : @sqlite.Database, params : ActivateUserParams) -> Int raise SqlError {
  let stmt = match db.prepare(activate_user_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.id)) |> ignore
  stmt.execute() |> ignore
  stmt.finalize()
  db.changes()
}

///| DeactivateUser
/// UPDATE users SET is_active = 0 WHERE id = ?
pub fn deactivate_user(db : @sqlite.Database, params : DeactivateUserParams) -> Int raise SqlError {
  let stmt = match db.prepare(deactivate_user_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.id)) |> ignore
  stmt.execute() |> ignore
  stmt.finalize()
  db.changes()
}

///| CountActiveUsers
/// SELECT COUNT(*) as count FROM users WHERE is_active = 1
pub fn count_active_users(db : @sqlite.Database) -> CountActiveUsersRow? raise SqlError {
  let stmt = match db.prepare(count_active_users_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  if stmt.step() {
    let row : CountActiveUsersRow = {
      count: stmt.column_int(0),
    }
    stmt.finalize()
    Some(row)
  } else {
    stmt.finalize()
    None
  }
}

///| SearchUsersByName
///  SELECT id, name, email, age, balance, is_active, bio, created_at FROM users WHERE name LIKE ? ORDER BY name
pub fn search_users_by_name(db : @sqlite.Database, params : SearchUsersByNameParams) -> Array[SearchUsersByNameRow] raise SqlError {
  let stmt = match db.prepare(search_users_by_name_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Text(@encoding.encode(@encoding.UTF8, params.name))) |> ignore
  let results : Array[SearchUsersByNameRow] = []
  while stmt.step() {
    let row : SearchUsersByNameRow = {
      id: stmt.column_int(0),
      name: bytes_to_string(stmt.column_text(1)),
      email: bytes_to_string(stmt.column_text(2)),
      age: (match stmt.column(3) { @sqlite.Null => None; _ => Some(stmt.column_int(3)) }),
      balance: (match stmt.column(4) { @sqlite.Null => None; _ => Some((match stmt.column(4) { @sqlite.Double(v) => v; @sqlite.Int(v) => v.to_double(); _ => 0.0 })) }),
      is_active: stmt.column_int(5),
      bio: (match stmt.column(6) { @sqlite.Null => None; _ => Some(bytes_to_string(stmt.column_text(6))) }),
      created_at: bytes_to_string(stmt.column_text(7)),
    }
    results.push(row)
  }
  stmt.finalize()
  results
}

///| ListUsersWithLimit
/// SELECT id, name, email, age, balance, is_active, bio, created_at FROM users ORDER BY id LIMIT ?
pub fn list_users_with_limit(db : @sqlite.Database, params : ListUsersWithLimitParams) -> Array[ListUsersWithLimitRow] raise SqlError {
  let stmt = match db.prepare(list_users_with_limit_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.limit)) |> ignore
  let results : Array[ListUsersWithLimitRow] = []
  while stmt.step() {
    let row : ListUsersWithLimitRow = {
      id: stmt.column_int(0),
      name: bytes_to_string(stmt.column_text(1)),
      email: bytes_to_string(stmt.column_text(2)),
      age: (match stmt.column(3) { @sqlite.Null => None; _ => Some(stmt.column_int(3)) }),
      balance: (match stmt.column(4) { @sqlite.Null => None; _ => Some((match stmt.column(4) { @sqlite.Double(v) => v; @sqlite.Int(v) => v.to_double(); _ => 0.0 })) }),
      is_active: stmt.column_int(5),
      bio: (match stmt.column(6) { @sqlite.Null => None; _ => Some(bytes_to_string(stmt.column_text(6))) }),
      created_at: bytes_to_string(stmt.column_text(7)),
    }
    results.push(row)
  }
  stmt.finalize()
  results
}

///| GetUserCount
/// SELECT COUNT(*) as count FROM users
pub fn get_user_count(db : @sqlite.Database) -> GetUserCountRow? raise SqlError {
  let stmt = match db.prepare(get_user_count_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  if stmt.step() {
    let row : GetUserCountRow = {
      count: stmt.column_int(0),
    }
    stmt.finalize()
    Some(row)
  } else {
    stmt.finalize()
    None
  }
}

///| CreatePost
///  INSERT INTO posts (author_id, title, content, is_published) VALUES (?, ?, ?, ?)
pub fn create_post(db : @sqlite.Database, params : CreatePostParams) -> Unit raise SqlError {
  let stmt = match db.prepare(create_post_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.author_id)) |> ignore
  stmt.bind(2, @sqlite.Text(@encoding.encode(@encoding.UTF8, params.title))) |> ignore
  stmt.bind(3, @sqlite.Text(@encoding.encode(@encoding.UTF8, params.content))) |> ignore
  stmt.bind(4, @sqlite.Int(params.is_published)) |> ignore
  stmt.execute() |> ignore
  stmt.finalize()
}

///| CreatePostReturningId
/// INSERT INTO posts (author_id, title, content, is_published) VALUES (?, ?, ?, ?)
pub fn create_post_returning_id(db : @sqlite.Database, params : CreatePostReturningIdParams) -> Int64 raise SqlError {
  let stmt = match db.prepare(create_post_returning_id_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.author_id)) |> ignore
  stmt.bind(2, @sqlite.Text(@encoding.encode(@encoding.UTF8, params.title))) |> ignore
  stmt.bind(3, @sqlite.Text(@encoding.encode(@encoding.UTF8, params.content))) |> ignore
  stmt.bind(4, @sqlite.Int(params.is_published)) |> ignore
  stmt.execute() |> ignore
  stmt.finalize()
  db.last_insert_rowid()
}

///| GetPostById
/// SELECT id, author_id, title, content, view_count, is_published, published_at, created_at FROM posts WHERE id = ?
pub fn get_post_by_id(db : @sqlite.Database, params : GetPostByIdParams) -> GetPostByIdRow? raise SqlError {
  let stmt = match db.prepare(get_post_by_id_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.id)) |> ignore
  if stmt.step() {
    let row : GetPostByIdRow = {
      id: stmt.column_int(0),
      author_id: stmt.column_int(1),
      title: bytes_to_string(stmt.column_text(2)),
      content: bytes_to_string(stmt.column_text(3)),
      view_count: stmt.column_int(4),
      is_published: stmt.column_int(5),
      published_at: (match stmt.column(6) { @sqlite.Null => None; _ => Some(bytes_to_string(stmt.column_text(6))) }),
      created_at: bytes_to_string(stmt.column_text(7)),
    }
    stmt.finalize()
    Some(row)
  } else {
    stmt.finalize()
    None
  }
}

///| ListPostsByAuthor
/// SELECT id, author_id, title, content, view_count, is_published, published_at, created_at FROM posts WHERE author_id = ? ORDER BY created_at DESC
pub fn list_posts_by_author(db : @sqlite.Database, params : ListPostsByAuthorParams) -> Array[ListPostsByAuthorRow] raise SqlError {
  let stmt = match db.prepare(list_posts_by_author_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.author_id)) |> ignore
  let results : Array[ListPostsByAuthorRow] = []
  while stmt.step() {
    let row : ListPostsByAuthorRow = {
      id: stmt.column_int(0),
      author_id: stmt.column_int(1),
      title: bytes_to_string(stmt.column_text(2)),
      content: bytes_to_string(stmt.column_text(3)),
      view_count: stmt.column_int(4),
      is_published: stmt.column_int(5),
      published_at: (match stmt.column(6) { @sqlite.Null => None; _ => Some(bytes_to_string(stmt.column_text(6))) }),
      created_at: bytes_to_string(stmt.column_text(7)),
    }
    results.push(row)
  }
  stmt.finalize()
  results
}

///| PublishPost
/// UPDATE posts SET is_published = 1, published_at = datetime('now') WHERE id = ?
pub fn publish_post(db : @sqlite.Database, params : PublishPostParams) -> Int raise SqlError {
  let stmt = match db.prepare(publish_post_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.id)) |> ignore
  stmt.execute() |> ignore
  stmt.finalize()
  db.changes()
}

///| DeletePost
/// DELETE FROM posts WHERE id = ?
pub fn delete_post(db : @sqlite.Database, params : DeletePostParams) -> Int raise SqlError {
  let stmt = match db.prepare(delete_post_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.id)) |> ignore
  stmt.execute() |> ignore
  stmt.finalize()
  db.changes()
}

///| IncrementViewCount
/// UPDATE posts SET view_count = view_count + 1 WHERE id = ?
pub fn increment_view_count(db : @sqlite.Database, params : IncrementViewCountParams) -> Int raise SqlError {
  let stmt = match db.prepare(increment_view_count_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.id)) |> ignore
  stmt.execute() |> ignore
  stmt.finalize()
  db.changes()
}

///| GetPostWithAuthor
///  SELECT   p.id, p.title, p.content, p.view_count, p.is_published,   p.published_at, p.created_at,   u.id as author_id, u.name as author_name, u.email as author_email FROM posts p INNER JOIN users u ON p.author_id = u.id WHERE p.id = ?
pub fn get_post_with_author(db : @sqlite.Database, params : GetPostWithAuthorParams) -> GetPostWithAuthorRow? raise SqlError {
  let stmt = match db.prepare(get_post_with_author_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.id)) |> ignore
  if stmt.step() {
    let row : GetPostWithAuthorRow = {
      id: stmt.column_int(0),
      title: bytes_to_string(stmt.column_text(1)),
      content: bytes_to_string(stmt.column_text(2)),
      view_count: stmt.column_int(3),
      is_published: stmt.column_int(4),
      published_at: (match stmt.column(5) { @sqlite.Null => None; _ => Some(bytes_to_string(stmt.column_text(5))) }),
      created_at: bytes_to_string(stmt.column_text(6)),
      author_id: stmt.column_int(7),
      author_name: bytes_to_string(stmt.column_text(8)),
      author_email: bytes_to_string(stmt.column_text(9)),
    }
    stmt.finalize()
    Some(row)
  } else {
    stmt.finalize()
    None
  }
}

///| ListPostsWithAuthors
/// SELECT   p.id, p.title, p.view_count, p.is_published, p.created_at,   u.id as author_id, u.name as author_name FROM posts p INNER JOIN users u ON p.author_id = u.id ORDER BY p.created_at DESC
pub fn list_posts_with_authors(db : @sqlite.Database) -> Array[ListPostsWithAuthorsRow] raise SqlError {
  let stmt = match db.prepare(list_posts_with_authors_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  let results : Array[ListPostsWithAuthorsRow] = []
  while stmt.step() {
    let row : ListPostsWithAuthorsRow = {
      id: stmt.column_int(0),
      title: bytes_to_string(stmt.column_text(1)),
      view_count: stmt.column_int(2),
      is_published: stmt.column_int(3),
      created_at: bytes_to_string(stmt.column_text(4)),
      author_id: stmt.column_int(5),
      author_name: bytes_to_string(stmt.column_text(6)),
    }
    results.push(row)
  }
  stmt.finalize()
  results
}

///| GetPostCountByAuthor
///  SELECT COUNT(*) as post_count FROM posts WHERE author_id = ?
pub fn get_post_count_by_author(db : @sqlite.Database, params : GetPostCountByAuthorParams) -> GetPostCountByAuthorRow? raise SqlError {
  let stmt = match db.prepare(get_post_count_by_author_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.author_id)) |> ignore
  if stmt.step() {
    let row : GetPostCountByAuthorRow = {
      post_count: stmt.column_int(0),
    }
    stmt.finalize()
    Some(row)
  } else {
    stmt.finalize()
    None
  }
}

///| GetAuthorStats
/// SELECT   COUNT(*) as post_count,   COALESCE(SUM(view_count), 0) as total_views FROM posts WHERE author_id = ?
pub fn get_author_stats(db : @sqlite.Database, params : GetAuthorStatsParams) -> GetAuthorStatsRow? raise SqlError {
  let stmt = match db.prepare(get_author_stats_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.author_id)) |> ignore
  if stmt.step() {
    let row : GetAuthorStatsRow = {
      post_count: stmt.column_int(0),
      total_views: (match stmt.column(1) { @sqlite.Null => None; _ => Some(bytes_to_string(stmt.column_text(1))) }),
    }
    stmt.finalize()
    Some(row)
  } else {
    stmt.finalize()
    None
  }
}

///| CreateTag
///  INSERT INTO tags (name) VALUES (?)
pub fn create_tag(db : @sqlite.Database, params : CreateTagParams) -> Unit raise SqlError {
  let stmt = match db.prepare(create_tag_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Text(@encoding.encode(@encoding.UTF8, params.name))) |> ignore
  stmt.execute() |> ignore
  stmt.finalize()
}

///| CreateTagReturningId
/// INSERT INTO tags (name) VALUES (?)
pub fn create_tag_returning_id(db : @sqlite.Database, params : CreateTagReturningIdParams) -> Int64 raise SqlError {
  let stmt = match db.prepare(create_tag_returning_id_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Text(@encoding.encode(@encoding.UTF8, params.name))) |> ignore
  stmt.execute() |> ignore
  stmt.finalize()
  db.last_insert_rowid()
}

///| GetTagByName
/// SELECT id, name FROM tags WHERE name = ?
pub fn get_tag_by_name(db : @sqlite.Database, params : GetTagByNameParams) -> GetTagByNameRow? raise SqlError {
  let stmt = match db.prepare(get_tag_by_name_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Text(@encoding.encode(@encoding.UTF8, params.name))) |> ignore
  if stmt.step() {
    let row : GetTagByNameRow = {
      id: stmt.column_int(0),
      name: bytes_to_string(stmt.column_text(1)),
    }
    stmt.finalize()
    Some(row)
  } else {
    stmt.finalize()
    None
  }
}

///| ListTags
/// SELECT id, name FROM tags ORDER BY name
pub fn list_tags(db : @sqlite.Database) -> Array[ListTagsRow] raise SqlError {
  let stmt = match db.prepare(list_tags_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  let results : Array[ListTagsRow] = []
  while stmt.step() {
    let row : ListTagsRow = {
      id: stmt.column_int(0),
      name: bytes_to_string(stmt.column_text(1)),
    }
    results.push(row)
  }
  stmt.finalize()
  results
}

///| DeleteTag
/// DELETE FROM tags WHERE id = ?
pub fn delete_tag(db : @sqlite.Database, params : DeleteTagParams) -> Int raise SqlError {
  let stmt = match db.prepare(delete_tag_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.id)) |> ignore
  stmt.execute() |> ignore
  stmt.finalize()
  db.changes()
}

///| AddTagToPost
///  INSERT INTO post_tags (post_id, tag_id) VALUES (?, ?)
pub fn add_tag_to_post(db : @sqlite.Database, params : AddTagToPostParams) -> Unit raise SqlError {
  let stmt = match db.prepare(add_tag_to_post_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.post_id)) |> ignore
  stmt.bind(2, @sqlite.Int(params.tag_id)) |> ignore
  stmt.execute() |> ignore
  stmt.finalize()
}

///| RemoveTagFromPost
/// DELETE FROM post_tags WHERE post_id = ? AND tag_id = ?
pub fn remove_tag_from_post(db : @sqlite.Database, params : RemoveTagFromPostParams) -> Int raise SqlError {
  let stmt = match db.prepare(remove_tag_from_post_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.post_id)) |> ignore
  stmt.bind(2, @sqlite.Int(params.tag_id)) |> ignore
  stmt.execute() |> ignore
  stmt.finalize()
  db.changes()
}

///| ListTagsForPost
/// SELECT t.id, t.name FROM tags t INNER JOIN post_tags pt ON t.id = pt.tag_id WHERE pt.post_id = ? ORDER BY t.name
pub fn list_tags_for_post(db : @sqlite.Database, params : ListTagsForPostParams) -> Array[ListTagsForPostRow] raise SqlError {
  let stmt = match db.prepare(list_tags_for_post_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.post_id)) |> ignore
  let results : Array[ListTagsForPostRow] = []
  while stmt.step() {
    let row : ListTagsForPostRow = {
      id: stmt.column_int(0),
      name: bytes_to_string(stmt.column_text(1)),
    }
    results.push(row)
  }
  stmt.finalize()
  results
}

///| GetTagCountForPost
/// SELECT COUNT(*) as tag_count FROM post_tags WHERE post_id = ?
pub fn get_tag_count_for_post(db : @sqlite.Database, params : GetTagCountForPostParams) -> GetTagCountForPostRow? raise SqlError {
  let stmt = match db.prepare(get_tag_count_for_post_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.post_id)) |> ignore
  if stmt.step() {
    let row : GetTagCountForPostRow = {
      tag_count: stmt.column_int(0),
    }
    stmt.finalize()
    Some(row)
  } else {
    stmt.finalize()
    None
  }
}

///| ListUsersPaginated
///  SELECT id, name, email, age, balance, is_active, bio, created_at FROM users WHERE id > ? ORDER BY id LIMIT ?
pub fn list_users_paginated(db : @sqlite.Database, params : ListUsersPaginatedParams) -> Array[ListUsersPaginatedRow] raise SqlError {
  let stmt = match db.prepare(list_users_paginated_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.id)) |> ignore
  stmt.bind(2, @sqlite.Int(params.limit)) |> ignore
  let results : Array[ListUsersPaginatedRow] = []
  while stmt.step() {
    let row : ListUsersPaginatedRow = {
      id: stmt.column_int(0),
      name: bytes_to_string(stmt.column_text(1)),
      email: bytes_to_string(stmt.column_text(2)),
      age: (match stmt.column(3) { @sqlite.Null => None; _ => Some(stmt.column_int(3)) }),
      balance: (match stmt.column(4) { @sqlite.Null => None; _ => Some((match stmt.column(4) { @sqlite.Double(v) => v; @sqlite.Int(v) => v.to_double(); _ => 0.0 })) }),
      is_active: stmt.column_int(5),
      bio: (match stmt.column(6) { @sqlite.Null => None; _ => Some(bytes_to_string(stmt.column_text(6))) }),
      created_at: bytes_to_string(stmt.column_text(7)),
    }
    results.push(row)
  }
  stmt.finalize()
  results
}

///| ListPostsByAuthorPaginated
/// SELECT id, author_id, title, content, view_count, is_published, published_at, created_at FROM posts WHERE author_id = ? AND id > ? ORDER BY id LIMIT ?
pub fn list_posts_by_author_paginated(db : @sqlite.Database, params : ListPostsByAuthorPaginatedParams) -> Array[ListPostsByAuthorPaginatedRow] raise SqlError {
  let stmt = match db.prepare(list_posts_by_author_paginated_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.author_id)) |> ignore
  stmt.bind(2, @sqlite.Int(params.id)) |> ignore
  stmt.bind(3, @sqlite.Int(params.limit)) |> ignore
  let results : Array[ListPostsByAuthorPaginatedRow] = []
  while stmt.step() {
    let row : ListPostsByAuthorPaginatedRow = {
      id: stmt.column_int(0),
      author_id: stmt.column_int(1),
      title: bytes_to_string(stmt.column_text(2)),
      content: bytes_to_string(stmt.column_text(3)),
      view_count: stmt.column_int(4),
      is_published: stmt.column_int(5),
      published_at: (match stmt.column(6) { @sqlite.Null => None; _ => Some(bytes_to_string(stmt.column_text(6))) }),
      created_at: bytes_to_string(stmt.column_text(7)),
    }
    results.push(row)
  }
  stmt.finalize()
  results
}

///| ListPostsWithAuthorsPaginated
/// SELECT   p.id, p.title, p.view_count, p.is_published, p.created_at,   u.id as author_id, u.name as author_name FROM posts p INNER JOIN users u ON p.author_id = u.id WHERE p.id > ? ORDER BY p.id LIMIT ?
pub fn list_posts_with_authors_paginated(db : @sqlite.Database, params : ListPostsWithAuthorsPaginatedParams) -> Array[ListPostsWithAuthorsPaginatedRow] raise SqlError {
  let stmt = match db.prepare(list_posts_with_authors_paginated_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.id)) |> ignore
  stmt.bind(2, @sqlite.Int(params.limit)) |> ignore
  let results : Array[ListPostsWithAuthorsPaginatedRow] = []
  while stmt.step() {
    let row : ListPostsWithAuthorsPaginatedRow = {
      id: stmt.column_int(0),
      title: bytes_to_string(stmt.column_text(1)),
      view_count: stmt.column_int(2),
      is_published: stmt.column_int(3),
      created_at: bytes_to_string(stmt.column_text(4)),
      author_id: stmt.column_int(5),
      author_name: bytes_to_string(stmt.column_text(6)),
    }
    results.push(row)
  }
  stmt.finalize()
  results
}

///| ListPublishedPostsPaginated
/// SELECT id, author_id, title, content, view_count, is_published, published_at, created_at FROM posts WHERE is_published = 1 AND id > ? ORDER BY id LIMIT ?
pub fn list_published_posts_paginated(db : @sqlite.Database, params : ListPublishedPostsPaginatedParams) -> Array[ListPublishedPostsPaginatedRow] raise SqlError {
  let stmt = match db.prepare(list_published_posts_paginated_sql) {
    Some(s) => s
    None => raise SqlError(bytes_to_string(db.errmsg()))
  }
  stmt.bind(1, @sqlite.Int(params.id)) |> ignore
  stmt.bind(2, @sqlite.Int(params.limit)) |> ignore
  let results : Array[ListPublishedPostsPaginatedRow] = []
  while stmt.step() {
    let row : ListPublishedPostsPaginatedRow = {
      id: stmt.column_int(0),
      author_id: stmt.column_int(1),
      title: bytes_to_string(stmt.column_text(2)),
      content: bytes_to_string(stmt.column_text(3)),
      view_count: stmt.column_int(4),
      is_published: stmt.column_int(5),
      published_at: (match stmt.column(6) { @sqlite.Null => None; _ => Some(bytes_to_string(stmt.column_text(6))) }),
      created_at: bytes_to_string(stmt.column_text(7)),
    }
    results.push(row)
  }
  stmt.finalize()
  results
}

