///|
/// Standalone SQL to MoonBit code generator
/// Usage: moon run tools/codegen --target native -- queries.sql

// Query definition parsed from comments
struct QueryDef {
  name : String
  cmd : String // :one, :many, :exec
  params : Array[(String, String)] // (name, type)
  returns : Array[(String, String)] // (name, type)
  sql : String
}

///|
fn main {
  let args = @sys.get_cli_args()
  if args.length() < 2 {
    println("Usage: codegen <queries.sql>")
    println("")
    println("SQL file format:")
    println("  -- @query GetUser :one")
    println("  -- @param id INTEGER")
    println("  -- @returns id INTEGER, name TEXT, email TEXT")
    println("  SELECT * FROM users WHERE id = ?;")
    return
  }
  let filename = args[1]
  let content = @fs.read_file_to_string(filename) catch {
    e => {
      println("Error reading file: " + e.to_string())
      return
    }
  }
  let queries = parse_queries(content)
  let code = generate_code(queries)
  println(code)
}

///|
fn parse_queries(content : String) -> Array[QueryDef] {
  let queries : Array[QueryDef] = []
  let lines = split_lines(content)
  let mut i = 0
  while i < lines.length() {
    let line = lines[i].trim().to_string()

    // Look for @query directive
    if line.has_prefix("-- @query ") {
      let parts = split_whitespace(substr(line, 10))
      if parts.length() >= 2 {
        let name = parts[0]
        let cmd = parts[1]
        let params : Array[(String, String)] = []
        let returns : Array[(String, String)] = []
        let sql_lines : Array[String] = []
        i = i + 1

        // Parse subsequent directives and SQL
        while i < lines.length() {
          let next_line = lines[i].trim().to_string()
          if next_line.has_prefix("-- @param ") {
            let param_str = substr(next_line, 10)
            let param_parts = split_whitespace(param_str)
            if param_parts.length() >= 2 {
              params.push((param_parts[0], param_parts[1]))
            }
          } else if next_line.has_prefix("-- @returns ") {
            let ret_str = substr(next_line, 12)
            let cols = split_by_comma(ret_str)
            for col in cols {
              let col_parts = split_whitespace(col.trim().to_string())
              if col_parts.length() >= 2 {
                returns.push((col_parts[0], col_parts[1]))
              }
            }
          } else if next_line.has_prefix("-- @query ") {
            // Next query starts, don't consume this line
            break
          } else if next_line.length() > 0 && not(next_line.has_prefix("--")) {
            // SQL line
            sql_lines.push(next_line)
            // Check if SQL ends with semicolon
            if next_line.has_suffix(";") {
              i = i + 1
              break
            }
          }
          i = i + 1
        }
        let sql = join_lines(sql_lines, " ")
        queries.push({ name, cmd, params, returns, sql })
        continue
      }
    }
    i = i + 1
  }
  queries
}

///|
fn generate_code(queries : Array[QueryDef]) -> String {
  let buf = StringBuilder::new()
  buf.write_string("// Generated by sqlc-gen-moonbit (standalone)\n\n")

  // Helper functions
  buf.write_string("///|\nfn cstring(s : String) -> Bytes {\n")
  buf.write_string("  @encoding.encode(@encoding.UTF8, s)\n")
  buf.write_string("}\n\n")
  buf.write_string("///|\nfn bytes_to_string(b : Bytes) -> String {\n")
  buf.write_string("  let decoder = @encoding.decoder(@encoding.UTF8)\n")
  buf.write_string("  decoder.decode_lossy(b[0:b.length()])\n")
  buf.write_string("}\n\n")

  // Generate structs and functions for each query
  for query in queries {
    generate_query(buf, query)
  }
  buf.to_string()
}

///|
fn generate_query(buf : StringBuilder, query : QueryDef) -> Unit {
  let func_name = to_snake_case(query.name)
  let row_type = query.name + "Row"
  let params_type = query.name + "Params"

  // Generate Row struct for :one and :many
  if (query.cmd == ":one" || query.cmd == ":many") && query.returns.length() > 0 {
    buf.write_string("///|\npub struct ")
    buf.write_string(row_type)
    buf.write_string(" {\n")
    for ret in query.returns {
      buf.write_string("  ")
      buf.write_string(to_snake_case(ret.0))
      buf.write_string(" : ")
      buf.write_string(sql_type_to_moonbit(ret.1))
      buf.write_string("\n")
    }
    buf.write_string("} derive(Show, Eq)\n\n")
  }

  // Generate Params struct
  if query.params.length() > 0 {
    buf.write_string("///|\npub struct ")
    buf.write_string(params_type)
    buf.write_string(" {\n")
    for param in query.params {
      buf.write_string("  ")
      buf.write_string(to_snake_case(param.0))
      buf.write_string(" : ")
      buf.write_string(sql_type_to_moonbit(param.1))
      buf.write_string("\n")
    }
    buf.write_string("} derive(Show, Eq)\n\n")

    // Constructor
    buf.write_string("///|\npub fn ")
    buf.write_string(params_type)
    buf.write_string("::new(")
    for i, param in query.params {
      if i > 0 {
        buf.write_string(", ")
      }
      buf.write_string(to_snake_case(param.0))
      buf.write_string(" : ")
      buf.write_string(sql_type_to_moonbit(param.1))
    }
    buf.write_string(") -> ")
    buf.write_string(params_type)
    buf.write_string(" {\n  { ")
    for i, param in query.params {
      if i > 0 {
        buf.write_string(", ")
      }
      buf.write_string(to_snake_case(param.0))
    }
    buf.write_string(" }\n}\n\n")
  }

  // SQL constant
  let sql_const = func_name + "_sql"
  buf.write_string("///|\npub let ")
  buf.write_string(sql_const)
  buf.write_string(" : String = \"")
  buf.write_string(escape_string(query.sql))
  buf.write_string("\"\n\n")

  // Generate function
  let return_type = match query.cmd {
    ":one" => row_type + "?"
    ":many" => "Array[" + row_type + "]"
    _ => "Unit"
  }
  buf.write_string("///| ")
  buf.write_string(query.name)
  buf.write_string("\npub fn ")
  buf.write_string(func_name)
  buf.write_string("(db : @sqlite.Sqlite3")
  if query.params.length() > 0 {
    buf.write_string(", params : ")
    buf.write_string(params_type)
  }
  buf.write_string(") -> ")
  buf.write_string(return_type)
  buf.write_string(" {\n")

  // Prepare
  buf.write_string("  let stmt = @sqlite.sqlite_prepare(db, cstring(")
  buf.write_string(sql_const)
  buf.write_string("))\n")

  // Bind parameters
  for i, param in query.params {
    let idx = (i + 1).to_string()
    let param_name = "params." + to_snake_case(param.0)
    buf.write_string("  ")
    buf.write_string(param_to_bind_call(param.1, idx, param_name))
    buf.write_string(" |> ignore\n")
  }

  // Execute based on cmd
  match query.cmd {
    ":one" => {
      buf.write_string(
        "  if @sqlite.sqlite_step(stmt) == @sqlite.SQLITE_ROW {\n",
      )
      buf.write_string("    let row : ")
      buf.write_string(row_type)
      buf.write_string(" = {\n")
      for i, ret in query.returns {
        buf.write_string("      ")
        buf.write_string(to_snake_case(ret.0))
        buf.write_string(": ")
        buf.write_string(column_to_moonbit(ret.1, i))
        buf.write_string(",\n")
      }
      buf.write_string("    }\n")
      buf.write_string("    @sqlite.sqlite_finalize(stmt)\n")
      buf.write_string("    Some(row)\n")
      buf.write_string("  } else {\n")
      buf.write_string("    @sqlite.sqlite_finalize(stmt)\n")
      buf.write_string("    None\n")
      buf.write_string("  }\n")
    }
    ":many" => {
      buf.write_string("  let results : Array[")
      buf.write_string(row_type)
      buf.write_string("] = []\n")
      buf.write_string(
        "  while @sqlite.sqlite_step(stmt) == @sqlite.SQLITE_ROW {\n",
      )
      buf.write_string("    let row : ")
      buf.write_string(row_type)
      buf.write_string(" = {\n")
      for i, ret in query.returns {
        buf.write_string("      ")
        buf.write_string(to_snake_case(ret.0))
        buf.write_string(": ")
        buf.write_string(column_to_moonbit(ret.1, i))
        buf.write_string(",\n")
      }
      buf.write_string("    }\n")
      buf.write_string("    results.push(row)\n")
      buf.write_string("  }\n")
      buf.write_string("  @sqlite.sqlite_finalize(stmt)\n")
      buf.write_string("  results\n")
    }
    _ => {
      buf.write_string("  @sqlite.sqlite_step(stmt) |> ignore\n")
      buf.write_string("  @sqlite.sqlite_finalize(stmt)\n")
    }
  }
  buf.write_string("}\n\n")
}

///|
fn sql_type_to_moonbit(sql_type : String) -> String {
  match sql_type.to_upper() {
    "INTEGER" | "INT" | "INT4" | "INT8" | "BIGINT" | "SMALLINT" => "Int64"
    "REAL" | "FLOAT" | "DOUBLE" | "NUMERIC" | "DECIMAL" => "Double"
    "TEXT" | "VARCHAR" | "CHAR" => "String"
    "BLOB" | "BYTEA" => "Bytes"
    "BOOLEAN" | "BOOL" => "Bool"
    _ => "String"
  }
}

///|
fn param_to_bind_call(sql_type : String, idx : String, expr : String) -> String {
  match sql_type.to_upper() {
    "INTEGER" | "INT" | "INT4" | "INT8" | "BIGINT" =>
      "@sqlite.sqlite_bind_int64(stmt, " + idx + ", " + expr + ")"
    "SMALLINT" =>
      "@sqlite.sqlite_bind_int(stmt, " + idx + ", " + expr + ".to_int())"
    "REAL" | "FLOAT" | "DOUBLE" =>
      "@sqlite.sqlite_bind_double(stmt, " + idx + ", " + expr + ")"
    "TEXT" | "VARCHAR" | "CHAR" =>
      "@sqlite.sqlite_bind_text(stmt, " + idx + ", cstring(" + expr + "))"
    "BLOB" | "BYTEA" =>
      "@sqlite.sqlite_bind_blob(stmt, " + idx + ", " + expr + ")"
    "BOOLEAN" | "BOOL" =>
      "@sqlite.sqlite_bind_int(stmt, " +
      idx +
      ", if " +
      expr +
      " { 1 } else { 0 })"
    _ => "@sqlite.sqlite_bind_text(stmt, " + idx + ", cstring(" + expr + "))"
  }
}

///|
fn column_to_moonbit(sql_type : String, idx : Int) -> String {
  let idx_str = idx.to_string()
  match sql_type.to_upper() {
    "INTEGER" | "INT" | "INT4" | "INT8" | "BIGINT" | "SMALLINT" =>
      "@sqlite.sqlite_column_int64(stmt, " + idx_str + ")"
    "REAL" | "FLOAT" | "DOUBLE" =>
      "@sqlite.sqlite_column_double(stmt, " + idx_str + ")"
    "TEXT" | "VARCHAR" | "CHAR" =>
      "bytes_to_string(@sqlite.sqlite_column_text(stmt, " + idx_str + "))"
    "BLOB" | "BYTEA" => "@sqlite.sqlite_column_blob(stmt, " + idx_str + ")"
    "BOOLEAN" | "BOOL" =>
      "@sqlite.sqlite_column_int(stmt, " + idx_str + ") != 0"
    _ => "bytes_to_string(@sqlite.sqlite_column_text(stmt, " + idx_str + "))"
  }
}

///|
fn to_snake_case(s : String) -> String {
  let buf = StringBuilder::new()
  let mut prev_lower = false
  for c in s {
    if c >= 'A' && c <= 'Z' {
      if prev_lower {
        buf.write_char('_')
      }
      buf.write_char((c.to_int() + 32).unsafe_to_char())
      prev_lower = false
    } else {
      buf.write_char(c)
      prev_lower = c >= 'a' && c <= 'z'
    }
  }
  buf.to_string()
}

///|
fn escape_string(s : String) -> String {
  let buf = StringBuilder::new()
  for c in s {
    match c {
      '"' => buf.write_string("\\\"")
      '\\' => buf.write_string("\\\\")
      '\n' => buf.write_string(" ")
      '\r' => ()
      '\t' => buf.write_string(" ")
      _ => buf.write_char(c)
    }
  }
  buf.to_string()
}

// String utility functions

///|
fn substr(s : String, start : Int) -> String {
  let buf = StringBuilder::new()
  let chars = s.to_array()
  for i = start; i < chars.length(); i = i + 1 {
    buf.write_char(chars[i])
  }
  buf.to_string()
}

///|
fn split_lines(s : String) -> Array[String] {
  let lines : Array[String] = []
  let buf = StringBuilder::new()
  for c in s {
    if c == '\n' {
      lines.push(buf.to_string())
      buf.reset()
    } else if c != '\r' {
      buf.write_char(c)
    }
  }
  if buf.to_string().length() > 0 {
    lines.push(buf.to_string())
  }
  lines
}

///|
fn split_whitespace(s : String) -> Array[String] {
  let parts : Array[String] = []
  let buf = StringBuilder::new()
  for c in s {
    if c == ' ' || c == '\t' {
      if buf.to_string().length() > 0 {
        parts.push(buf.to_string())
        buf.reset()
      }
    } else {
      buf.write_char(c)
    }
  }
  if buf.to_string().length() > 0 {
    parts.push(buf.to_string())
  }
  parts
}

///|
fn split_by_comma(s : String) -> Array[String] {
  let parts : Array[String] = []
  let buf = StringBuilder::new()
  for c in s {
    if c == ',' {
      parts.push(buf.to_string())
      buf.reset()
    } else {
      buf.write_char(c)
    }
  }
  if buf.to_string().length() > 0 {
    parts.push(buf.to_string())
  }
  parts
}

///|
fn join_lines(lines : Array[String], sep : String) -> String {
  let buf = StringBuilder::new()
  for i, line in lines {
    if i > 0 {
      buf.write_string(sep)
    }
    buf.write_string(line)
  }
  buf.to_string()
}
